{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{GXRX:function(){!function(){\"use strict\";function t(t,e){var o=\"function\"==typeof Symbol&&t[Symbol.iterator];if(!o)return t;var l,n,r=o.call(t),i=[];try{for(;(void 0===e||e-- >0)&&!(l=r.next()).done;)i.push(l.value)}catch(t){n={error:t}}finally{try{l&&!l.done&&(o=r.return)&&o.call(r)}finally{if(n)throw n.error}}return i}function e(){return null!=document.scrollingElement?document.scrollingElement:document.documentElement}function o(t,e){var o=\"scroll-behavior:\"+e,n=t.getAttribute(\"style\");if(null!=n&&\"\"!==n){var r=l(t);if(null!=r){var i=\"scroll-behavior:\"+r;n=(n=n.replace(i+\";\",\"\")).replace(i,\"\")}t.setAttribute(\"style\",n.endsWith(\";\")?\"\"+n+o:\";\"+n+o)}else t.setAttribute(\"style\",o)}function l(e){var o=e.getAttribute(\"style\");if(null!=o&&o.includes(I)){var l=o.match(L);if(null!=l){var n=t(l,2)[1];if(null!=n&&\"\"!==n)return n}}}function n(t,o){if(null!=o&&\"smooth\"===o.behavior)return\"smooth\";var n,r=\"style\"in t?t:e();if(\"style\"in r){var i=r.style.scrollBehavior;null!=i&&\"\"!==i&&(n=i)}if(null==n){var s=r.getAttribute(\"scroll-behavior\");null!=s&&\"\"!==s&&(n=s)}if(null==n&&(n=l(r)),null==n){var c=getComputedStyle(r).getPropertyValue(\"scrollBehavior\");null!=c&&\"\"!==c&&(n=c)}return n}function r(t){return.5*(1-Math.cos(Math.PI*t))}function i(t){var n=t.startTime,i=t.startX,s=t.startY,c=t.endX,a=t.endY,u=t.method,d=t.scroller,p=0,f=c-i,h=a-s,y=Math.max(Math.abs(f/1e3*15e3),Math.abs(h/1e3*15e3)),w=function(t){function n(){w.removeEventListener(\"scroll\",r),null!=j&&j.delete(t),y=!0}function r(){t.style.scrollSnapType=i,null!=c&&void 0!==a&&(c.style.scrollSnapType=a),void 0!==s&&o(t,s),void 0!==c&&void 0!==u&&o(c,u),n()}if(V||null==j)return P;var i,s,c,a,u,d=e(),p=j.get(t);if(null!=p)i=p.cachedScrollSnapValue,s=p.cachedScrollBehaviorStyleAttributeValue,c=p.secondaryScroller,a=p.secondaryScrollerCachedScrollSnapValue,u=p.secondaryScrollerCachedScrollBehaviorStyleAttributeValue,p.release();else{i=\"\"===t.style.scrollSnapType?null:t.style.scrollSnapType,s=l(t),c=t===d&&d!==document.body?document.body:void 0,a=null==c?void 0:\"\"===c.style.scrollSnapType?null:c.style.scrollSnapType,u=null==c?void 0:l(c);var f=getComputedStyle(t).getPropertyValue(\"scroll-snap-type\"),h=null==c?void 0:getComputedStyle(c).getPropertyValue(\"scroll-snap-type\");if(\"none\"===f&&\"none\"===h)return P}t.style.scrollSnapType=\"none\",void 0!==c&&(c.style.scrollSnapType=\"none\"),void 0!==s&&o(t,s),void 0!==c&&void 0!==u&&o(c,u);var y=!1,w=t===d?window:t;return j.set(t,{release:n,cachedScrollSnapValue:i,cachedScrollBehaviorStyleAttributeValue:s,secondaryScroller:c,secondaryScrollerCachedScrollSnapValue:a,secondaryScrollerCachedScrollBehaviorStyleAttributeValue:u}),{reset:function(){setTimeout((function(){y||w.addEventListener(\"scroll\",r)}))}}}(d);requestAnimationFrame((function t(e){p+=e-n;var o=Math.max(0,Math.min(1,0===y?0:p/y)),l=Math.floor(i+f*r(o)),d=Math.floor(s+h*r(o));u(l,d),l!==c||d!==a?requestAnimationFrame(t):null!=w&&(w.reset(),w=void 0)}))}function s(t,e){this.__adjustingScrollPosition=!0,this.scrollLeft=t,this.scrollTop=e,delete this.__adjustingScrollPosition}function c(t,e){return s.call(this,t,e)}function a(t,e){this.__adjustingScrollPosition=!0,this.scrollLeft+=t,this.scrollTop+=e,delete this.__adjustingScrollPosition}function u(t,e){switch(t){case\"scroll\":return e instanceof Element?null!=W?W:s:X;case\"scrollBy\":return e instanceof Element?null!=O?O:a:A;case\"scrollTo\":return e instanceof Element?null!=Y?Y:c:_}}function d(t,o,l,n){var r=\"performance\"in window?performance.now():Date.now();if(t instanceof Element)return{startTime:r,startX:i=t.scrollLeft,startY:s=t.scrollTop,endX:Math.floor(\"scrollBy\"===n?i+o:o),endY:Math.floor(\"scrollBy\"===n?s+l:l),method:u(\"scrollTo\",t).bind(t),scroller:t};var i,s,c=window.scrollX,a=window.pageXOffset,d=window.scrollY,p=window.pageYOffset;return{startTime:r,startX:i=null==c||0===c?a:c,startY:s=null==d||0===d?p:d,endX:Math.floor(\"scrollBy\"===n?i+o:o),endY:Math.floor(\"scrollBy\"===n?s+l:l),method:u(\"scrollTo\",window).bind(window),scroller:e()}}function p(t){return null==t?0:\"number\"==typeof t?t:\"string\"==typeof t?parseFloat(t):0}function f(t){return null!=t&&\"object\"==typeof t}function h(t,e,o,l){!function(t,e,o){var l=n(e,t);null==l||\"auto\"===l?u(o,e).call(e,t.left,t.top):i(d(e,t.left,t.top,o))}(function(t,e){if(void 0===e&&!f(t))throw new TypeError(\"Failed to execute 'scroll' on 'Element': parameter 1 ('options') is not an object.\");return f(t)?B(B({},y(t.left,t.top)),{behavior:null==t.behavior?\"auto\":t.behavior}):B(B({},y(t,e)),{behavior:\"auto\"})}(o,l),t,e)}function y(t,e){return{left:p(t),top:p(e)}}function w(t){return\"nodeType\"in t&&1===t.nodeType?t.parentNode:\"ShadowRoot\"in window&&t instanceof window.ShadowRoot?t.host:t===document?window:t instanceof Node?t.parentNode:null}function v(t){return\"visible\"!==t&&\"clip\"!==t}function m(t){if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){var e=getComputedStyle(t,null);return v(e.overflowY)||v(e.overflowX)}return!1}function g(t){for(var o=t,l=e();null!=o;){var r=n(o);if(null!=r&&(o===l||m(o)))return[o,r];o=w(o)}for(o=t;null!=o;){if(o===l||m(o))return[o,\"auto\"];o=w(o)}return[l,\"auto\"]}function b(t){if(void 0===t&&(t=location),\"origin\"in t&&null!=t.origin)return t.origin;var e=null!=t.port&&t.port.length>0?\":\"+t.port:\"\";return(\"http:\"===t.protocol&&\":80\"===e||\"https:\"===t.protocol&&\":443\"===e)&&(e=\"\"),t.protocol+\"//\"+t.hostname+e}function S(){window.addEventListener(\"click\",(function(e){if(e.isTrusted&&e.target instanceof HTMLAnchorElement){var o=e.target,l=o.pathname,n=o.search,r=o.hash;if(b(e.target)===b(location)&&l===location.pathname&&n===location.search&&null!=r&&!(r.length<1)){var i=function(t){for(var e=t;null!=e;){if(\"ShadowRoot\"in window&&e instanceof window.ShadowRoot)return e;var o=w(e);if(o===e)return document;e=o}return document}(e.target),s=null!=r.match(C)?i.getElementById(r.slice(1)):i.querySelector(r);if(null!=s){var c=t(g(s),2)[1];\"smooth\"===c&&(e.preventDefault(),s.scrollIntoView({behavior:c}))}}}}))}function T(t,e,o,l,n,r,i,s){return r<t&&i>e||r>t&&i<e?0:r<=t&&s<=o||i>=e&&s>=o?r-t-l:i>e&&s<o||r<t&&s>o?i-e+n:0}function E(t,o,l){var n=l.block,r=l.inline,i=e(),s=null!=window.visualViewport?visualViewport.width:innerWidth,c=null!=window.visualViewport?visualViewport.height:innerHeight,a=null!=window.scrollX?window.scrollX:window.pageXOffset,u=null!=window.scrollY?window.scrollY:window.pageYOffset,d=t.getBoundingClientRect(),p=d.height,f=d.width,h=d.top,y=d.left,w=\"start\"===n||\"nearest\"===n?h:\"end\"===n?d.bottom:h+p/2,v=\"center\"===r?y+f/2:\"end\"===r?d.right:y,m=o.getBoundingClientRect(),g=m.height,b=m.width,S=m.top,E=m.right,M=m.bottom,V=m.left,B=getComputedStyle(o),I=parseInt(B.borderLeftWidth,10),L=parseInt(B.borderTopWidth,10),P=parseInt(B.borderRightWidth,10),j=parseInt(B.borderBottomWidth,10),W=0,X=0,O=\"offsetWidth\"in o?o.offsetWidth-o.clientWidth-I-P:0,A=\"offsetHeight\"in o?o.offsetHeight-o.clientHeight-L-j:0;if(i===o)W=\"start\"===n?w:\"end\"===n?w-c:\"nearest\"===n?T(u,u+c,c,L,j,u+w,u+w+p,p):w-c/2,X=\"start\"===r?v:\"center\"===r?v-s/2:\"end\"===r?v-s:T(a,a+s,s,I,P,a+v,a+v+f,f),W=Math.max(0,W+u),X=Math.max(0,X+a);else{W=\"start\"===n?w-S-L:\"end\"===n?w-M+j+A:\"nearest\"===n?T(S,M,g,L,j+A,w,w+p,p):w-(S+g/2)+A/2,X=\"start\"===r?v-V-I:\"center\"===r?v-(V+b/2)+O/2:\"end\"===r?v-E+P+O:T(V,E,b,I,P+O,v,v+f,f);var Y=o.scrollLeft;W=Math.max(0,Math.min(o.scrollTop+W,o.scrollHeight-g+A)),X=Math.max(0,Math.min(Y+X,o.scrollWidth-b+O))}return{top:W,left:X}}var M=\"undefined\"==typeof window,V=!M&&\"scrollBehavior\"in document.documentElement.style,B=function(){return(B=Object.assign||function(t){for(var e,o=1,l=arguments.length;o<l;o++)for(var n in e=arguments[o])Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t}).apply(this,arguments)},I=\"scroll-behavior\",L=new RegExp(\"scroll-behavior:\\\\s*([^;]*)\"),P={reset:function(){}},j=\"undefined\"==typeof WeakMap?void 0:new WeakMap,W=M?void 0:Element.prototype.scroll,X=M?void 0:window.scroll,O=M?void 0:Element.prototype.scrollBy,A=M?void 0:window.scrollBy,Y=M?void 0:Element.prototype.scrollTo,_=M?void 0:window.scrollTo,C=/^#\\d/,H=M?void 0:Element.prototype.scrollIntoView,x=M?void 0:Object.getOwnPropertyDescriptor(Element.prototype,\"scrollTop\").set,R=M?void 0:Object.getOwnPropertyDescriptor(Element.prototype,\"scrollLeft\").set,k=!M&&(\"scroll\"in Element.prototype&&\"scrollTo\"in Element.prototype&&\"scrollBy\"in Element.prototype&&\"scrollIntoView\"in Element.prototype);M||V&&k||(Element.prototype.scroll=function(t,e){h(this,\"scroll\",t,e)},Element.prototype.scrollBy=function(t,e){h(this,\"scrollBy\",t,e)},Element.prototype.scrollTo=function(t,e){h(this,\"scrollTo\",t,e)},Element.prototype.scrollIntoView=function(e){var o=null==e||!0===e?{block:\"start\",inline:\"nearest\"}:!1===e?{block:\"end\",inline:\"nearest\"}:e,l=t(g(this),2),n=l[0],r=null!=o.behavior?o.behavior:l[1];if(\"smooth\"===r)n.scrollTo(B({behavior:r},E(this,n,o)));else if(null!=H)H.call(this,o);else{var i=E(this,n,o),s=i.top,c=i.left;u(\"scrollTo\",this).call(this,c,s)}},null!=HTMLElement.prototype.scrollIntoView&&HTMLElement.prototype.scrollIntoView!==Element.prototype.scrollIntoView&&(HTMLElement.prototype.scrollIntoView=Element.prototype.scrollIntoView),Object.defineProperty(Element.prototype,\"scrollLeft\",{set:function(t){return this.__adjustingScrollPosition?R.call(this,t):(h(this,\"scrollTo\",t,this.scrollTop),t)}}),Object.defineProperty(Element.prototype,\"scrollTop\",{set:function(t){return this.__adjustingScrollPosition?x.call(this,t):(h(this,\"scrollTo\",this.scrollLeft,t),t)}}),window.scroll=function(t,e){h(this,\"scroll\",t,e)},window.scrollBy=function(t,e){h(this,\"scrollBy\",t,e)},window.scrollTo=function(t,e){h(this,\"scrollTo\",t,e)},S())}()}}]);","name":"2.chunk.77f79.js","map":{"version":3,"sources":["2.chunk.77f79.js"],"names":["window","push","GXRX","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","value","error","getScrollingElement","document","scrollingElement","documentElement","appendScrollBehaviorToStyleAttribute","element","behavior","addition","STYLE_ATTRIBUTE_PROPERTY_NAME","attributeValue","getAttribute","existingValueForProperty","parseScrollBehaviorFromStyleAttribute","replacementProperty","replace","setAttribute","endsWith","styleAttributeValue","includes","match","STYLE_ATTRIBUTE_PROPERTY_REGEXP","getScrollBehavior","inputTarget","options","target","scrollBehaviorPropertyValue","style","computedStyleValue","getComputedStyle","getPropertyValue","ease","k","Math","cos","PI","smoothScroll","startTime","startX","startY","endX","endY","method","scroller","timeLapsed","distanceX","distanceY","speed","max","abs","scrollSnapFix","release","eventTarget","removeEventListener","resetHandler","map","hasReleased","scrollSnapType","cachedScrollSnapValue","secondaryScroller","undefined","secondaryScrollerCachedScrollSnapValue","cachedScrollBehaviorStyleAttributeValue","secondaryScrollerCachedScrollBehaviorStyleAttributeValue","SUPPORTS_SCROLL_BEHAVIOR","NOOP","existingResult","get","body","cachedComputedScrollSnapValue","secondaryScrollerCachedComputedScrollSnapValue","set","reset","setTimeout","addEventListener","disableScrollSnap","requestAnimationFrame","animate","timestamp","percentage","min","positionX","floor","positionY","elementPrototypeScrollFallback","x","y","this","__adjustingScrollPosition","scrollLeft","scrollTop","elementPrototypeScrollToFallback","elementPrototypeScrollByFallback","getOriginalScrollMethodForKind","kind","Element","ELEMENT_ORIGINAL_SCROLL","WINDOW_ORIGINAL_SCROLL","ELEMENT_ORIGINAL_SCROLL_BY","WINDOW_ORIGINAL_SCROLL_BY","ELEMENT_ORIGINAL_SCROLL_TO","WINDOW_ORIGINAL_SCROLL_TO","getSmoothScrollOptions","performance","now","Date","bind","scrollX_1","scrollX","pageXOffset_1","pageXOffset","scrollY_1","scrollY","pageYOffset_1","pageYOffset","ensureNumeric","parseFloat","isScrollToOptions","handleScrollMethod","optionsOrX","left","top","onScrollWithOptions","TypeError","_assign","normalizeScrollCoordinates","getScrollToOptionsWithValidation","getParent","currentElement","nodeType","parentNode","ShadowRoot","host","Node","canOverflow","overflow","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","overflowY","overflowX","findNearestAncestorsWithScrollBehavior","getLocationOrigin","locationLike","location","origin","port","length","protocol","hostname","catchNavigation","isTrusted","HTMLAnchorElement","_a","pathname","search","hash","root","parent_1","findNearestRoot","elementMatch","ID_WITH_LEADING_DIGIT_REGEXP","getElementById","slice","querySelector","preventDefault","scrollIntoView","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","computeScrollIntoView","block","inline","viewportWidth","visualViewport","width","innerWidth","viewportHeight","height","innerHeight","viewportX","viewportY","getBoundingClientRect","targetHeight","targetWidth","targetTop","targetLeft","targetBlock","bottom","targetInline","right","_b","frameStyle","borderLeft","parseInt","borderLeftWidth","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","blockScroll","inlineScroll","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","UNSUPPORTED_ENVIRONMENT","Object","assign","t","s","arguments","p","prototype","hasOwnProperty","apply","RegExp","WeakMap","scroll","scrollBy","scrollTo","ELEMENT_ORIGINAL_SCROLL_INTO_VIEW","ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR","getOwnPropertyDescriptor","ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR","SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS","arg","normalizedOptions","ancestorWithScroll","top_1","HTMLElement","defineProperty"],"mappings":"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"},"input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[2],{\n\n/***/ \"GXRX\":\n/***/ (function(module, exports) {\n\n(function () {\n  'use strict';\n\n  var UNSUPPORTED_ENVIRONMENT = typeof window === \"undefined\";\n  /**\n   * Is true if the browser natively supports the 'scroll-behavior' CSS-property.\n   * @type {boolean}\n   */\n\n  var SUPPORTS_SCROLL_BEHAVIOR = UNSUPPORTED_ENVIRONMENT ? false : \"scrollBehavior\" in document.documentElement.style;\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  var _assign = function __assign() {\n    _assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n\n        for (var p in s) {\n          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n      }\n\n      return t;\n    };\n\n    return _assign.apply(this, arguments);\n  };\n\n  function __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n\n    try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n        ar.push(r.value);\n      }\n    } catch (error) {\n      e = {\n        error: error\n      };\n    } finally {\n      try {\n        if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      } finally {\n        if (e) throw e.error;\n      }\n    }\n\n    return ar;\n  }\n\n  function getScrollingElement() {\n    if (document.scrollingElement != null) {\n      return document.scrollingElement;\n    } else {\n      return document.documentElement;\n    }\n  }\n\n  var STYLE_ATTRIBUTE_PROPERTY_NAME = \"scroll-behavior\";\n  var STYLE_ATTRIBUTE_PROPERTY_REGEXP = new RegExp(STYLE_ATTRIBUTE_PROPERTY_NAME + \":\\\\s*([^;]*)\");\n  /**\n   * Given an Element, this function appends the given ScrollBehavior CSS property value to the elements' 'style' attribute.\n   * If it doesnt already have one, it will add it.\n   * @param {Element} element\n   * @param {ScrollBehavior} behavior\n   */\n\n  function appendScrollBehaviorToStyleAttribute(element, behavior) {\n    var addition = STYLE_ATTRIBUTE_PROPERTY_NAME + \":\" + behavior;\n    var attributeValue = element.getAttribute(\"style\");\n\n    if (attributeValue == null || attributeValue === \"\") {\n      element.setAttribute(\"style\", addition);\n      return;\n    } // The style attribute may already include a 'scroll-behavior:<something>' in which case that should be replaced\n\n\n    var existingValueForProperty = parseScrollBehaviorFromStyleAttribute(element);\n\n    if (existingValueForProperty != null) {\n      var replacementProperty = STYLE_ATTRIBUTE_PROPERTY_NAME + \":\" + existingValueForProperty; // Replace the variant that ends with a semi-colon which it may\n\n      attributeValue = attributeValue.replace(replacementProperty + \";\", \"\"); // Replace the variant that *doesn't* end with a semi-colon\n\n      attributeValue = attributeValue.replace(replacementProperty, \"\");\n    } // Now, append the behavior to the string.\n\n\n    element.setAttribute(\"style\", attributeValue.endsWith(\";\") ? \"\" + attributeValue + addition : \";\" + attributeValue + addition);\n  }\n  /**\n   * Given an Element, this function attempts to parse its 'style' attribute (if it has one)' to extract\n   * a value for the 'scroll-behavior' CSS property (if it is given within that style attribute)\n   * @param {Element} element\n   * @returns {ScrollBehavior?}\n   */\n\n\n  function parseScrollBehaviorFromStyleAttribute(element) {\n    var styleAttributeValue = element.getAttribute(\"style\");\n\n    if (styleAttributeValue != null && styleAttributeValue.includes(STYLE_ATTRIBUTE_PROPERTY_NAME)) {\n      var match = styleAttributeValue.match(STYLE_ATTRIBUTE_PROPERTY_REGEXP);\n\n      if (match != null) {\n        var _a = __read(match, 2),\n            behavior = _a[1];\n\n        if (behavior != null && behavior !== \"\") {\n          return behavior;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  var styleDeclarationPropertyName = \"scrollBehavior\";\n  /**\n   * Determines the scroll behavior to use, depending on the given ScrollOptions and the position of the Element\n   * within the DOM\n   * @param {Element|HTMLElement|Window} inputTarget\n   * @param {ScrollOptions} [options]\n   * @returns {ScrollBehavior}\n   */\n\n  function getScrollBehavior(inputTarget, options) {\n    // If the given 'behavior' is 'smooth', apply smooth scrolling no matter what\n    if (options != null && options.behavior === \"smooth\") return \"smooth\";\n    var target = \"style\" in inputTarget ? inputTarget : getScrollingElement();\n    var value;\n\n    if (\"style\" in target) {\n      // Check if scroll-behavior is set as a property on the CSSStyleDeclaration\n      var scrollBehaviorPropertyValue = target.style[styleDeclarationPropertyName]; // Return it if it is given and has a proper value\n\n      if (scrollBehaviorPropertyValue != null && scrollBehaviorPropertyValue !== \"\") {\n        value = scrollBehaviorPropertyValue;\n      }\n    }\n\n    if (value == null) {\n      var attributeValue = target.getAttribute(\"scroll-behavior\");\n\n      if (attributeValue != null && attributeValue !== \"\") {\n        value = attributeValue;\n      }\n    }\n\n    if (value == null) {\n      // Otherwise, check if it is set as an inline style\n      value = parseScrollBehaviorFromStyleAttribute(target);\n    }\n\n    if (value == null) {\n      // Take the computed style for the element and see if it contains a specific 'scroll-behavior' value\n      var computedStyle = getComputedStyle(target);\n      var computedStyleValue = computedStyle.getPropertyValue(\"scrollBehavior\");\n\n      if (computedStyleValue != null && computedStyleValue !== \"\") {\n        value = computedStyleValue;\n      }\n    } // In all other cases, use the value from the CSSOM\n\n\n    return value;\n  }\n\n  var HALF = 0.5;\n  /**\n   * The easing function to use when applying the smooth scrolling\n   * @param {number} k\n   * @returns {number}\n   */\n\n  function ease(k) {\n    return HALF * (1 - Math.cos(Math.PI * k));\n  }\n\n  var NOOP = {\n    reset: function reset() {}\n  };\n  var map = typeof WeakMap === \"undefined\" ? undefined : new WeakMap();\n\n  function disableScrollSnap(scroller) {\n    // If scroll-behavior is natively supported, or if there is no native WeakMap support, there's no need for this fix\n    if (SUPPORTS_SCROLL_BEHAVIOR || map == null) {\n      return NOOP;\n    }\n\n    var scrollingElement = getScrollingElement();\n    var cachedScrollSnapValue;\n    var cachedScrollBehaviorStyleAttributeValue;\n    var secondaryScroller;\n    var secondaryScrollerCachedScrollSnapValue;\n    var secondaryScrollerCachedScrollBehaviorStyleAttributeValue;\n    var existingResult = map.get(scroller);\n\n    if (existingResult != null) {\n      cachedScrollSnapValue = existingResult.cachedScrollSnapValue;\n      cachedScrollBehaviorStyleAttributeValue = existingResult.cachedScrollBehaviorStyleAttributeValue;\n      secondaryScroller = existingResult.secondaryScroller;\n      secondaryScrollerCachedScrollSnapValue = existingResult.secondaryScrollerCachedScrollSnapValue;\n      secondaryScrollerCachedScrollBehaviorStyleAttributeValue = existingResult.secondaryScrollerCachedScrollBehaviorStyleAttributeValue;\n      existingResult.release();\n    } else {\n      cachedScrollSnapValue = scroller.style.scrollSnapType === \"\" ? null : scroller.style.scrollSnapType;\n      cachedScrollBehaviorStyleAttributeValue = parseScrollBehaviorFromStyleAttribute(scroller);\n      secondaryScroller = scroller === scrollingElement && scrollingElement !== document.body ? document.body : undefined;\n      secondaryScrollerCachedScrollSnapValue = secondaryScroller == null ? undefined : secondaryScroller.style.scrollSnapType === \"\" ? null : secondaryScroller.style.scrollSnapType;\n      secondaryScrollerCachedScrollBehaviorStyleAttributeValue = secondaryScroller == null ? undefined : parseScrollBehaviorFromStyleAttribute(secondaryScroller);\n      var cachedComputedScrollSnapValue = getComputedStyle(scroller).getPropertyValue(\"scroll-snap-type\");\n      var secondaryScrollerCachedComputedScrollSnapValue = secondaryScroller == null ? undefined : getComputedStyle(secondaryScroller).getPropertyValue(\"scroll-snap-type\"); // If it just so happens that there actually isn't any scroll snapping going on, there's no point in performing any additional work here.\n\n      if (cachedComputedScrollSnapValue === \"none\" && secondaryScrollerCachedComputedScrollSnapValue === \"none\") {\n        return NOOP;\n      }\n    }\n\n    scroller.style.scrollSnapType = \"none\";\n\n    if (secondaryScroller !== undefined) {\n      secondaryScroller.style.scrollSnapType = \"none\";\n    }\n\n    if (cachedScrollBehaviorStyleAttributeValue !== undefined) {\n      appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);\n    }\n\n    if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {\n      appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);\n    }\n\n    var hasReleased = false;\n    var eventTarget = scroller === scrollingElement ? window : scroller;\n\n    function release() {\n      eventTarget.removeEventListener(\"scroll\", resetHandler);\n\n      if (map != null) {\n        map[\"delete\"](scroller);\n      }\n\n      hasReleased = true;\n    }\n\n    function resetHandler() {\n      scroller.style.scrollSnapType = cachedScrollSnapValue;\n\n      if (secondaryScroller != null && secondaryScrollerCachedScrollSnapValue !== undefined) {\n        secondaryScroller.style.scrollSnapType = secondaryScrollerCachedScrollSnapValue;\n      }\n\n      if (cachedScrollBehaviorStyleAttributeValue !== undefined) {\n        appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);\n      }\n\n      if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {\n        appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);\n      }\n\n      release();\n    }\n\n    function reset() {\n      setTimeout(function () {\n        if (hasReleased) return;\n        eventTarget.addEventListener(\"scroll\", resetHandler);\n      });\n    }\n\n    map.set(scroller, {\n      release: release,\n      cachedScrollSnapValue: cachedScrollSnapValue,\n      cachedScrollBehaviorStyleAttributeValue: cachedScrollBehaviorStyleAttributeValue,\n      secondaryScroller: secondaryScroller,\n      secondaryScrollerCachedScrollSnapValue: secondaryScrollerCachedScrollSnapValue,\n      secondaryScrollerCachedScrollBehaviorStyleAttributeValue: secondaryScrollerCachedScrollBehaviorStyleAttributeValue\n    });\n    return {\n      reset: reset\n    };\n  }\n  /**\n   * The duration of a smooth scroll\n   * @type {number}\n   */\n\n\n  var SCROLL_TIME = 15000;\n  /**\n   * Performs a smooth repositioning of the scroll\n   * @param {ISmoothScrollOptions} options\n   */\n\n  function smoothScroll(options) {\n    var startTime = options.startTime,\n        startX = options.startX,\n        startY = options.startY,\n        endX = options.endX,\n        endY = options.endY,\n        method = options.method,\n        scroller = options.scroller;\n    var timeLapsed = 0;\n    var distanceX = endX - startX;\n    var distanceY = endY - startY;\n    var speed = Math.max(Math.abs(distanceX / 1000 * SCROLL_TIME), Math.abs(distanceY / 1000 * SCROLL_TIME)); // Temporarily disables any scroll snapping that may be active since it fights for control over the scroller with this polyfill\n\n    var scrollSnapFix = disableScrollSnap(scroller);\n    requestAnimationFrame(function animate(timestamp) {\n      timeLapsed += timestamp - startTime;\n      var percentage = Math.max(0, Math.min(1, speed === 0 ? 0 : timeLapsed / speed));\n      var positionX = Math.floor(startX + distanceX * ease(percentage));\n      var positionY = Math.floor(startY + distanceY * ease(percentage));\n      method(positionX, positionY);\n\n      if (positionX !== endX || positionY !== endY) {\n        requestAnimationFrame(animate);\n      } else {\n        if (scrollSnapFix != null) {\n          scrollSnapFix.reset();\n          scrollSnapFix = undefined;\n        }\n      }\n    });\n  }\n  /**\n   * Returns a High Resolution timestamp if possible, otherwise fallbacks to Date.now()\n   * @returns {number}\n   */\n\n\n  function now() {\n    if (\"performance\" in window) return performance.now();\n    return Date.now();\n  }\n\n  var ELEMENT_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scroll;\n  var WINDOW_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : window.scroll;\n  var ELEMENT_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollBy;\n  var WINDOW_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollBy;\n  var ELEMENT_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollTo;\n  var WINDOW_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollTo;\n  /**\n   * A fallback if Element.prototype.scroll is not defined\n   * @param {number} x\n   * @param {number} y\n   */\n\n  function elementPrototypeScrollFallback(x, y) {\n    this.__adjustingScrollPosition = true;\n    this.scrollLeft = x;\n    this.scrollTop = y;\n    delete this.__adjustingScrollPosition;\n  }\n  /**\n   * A fallback if Element.prototype.scrollTo is not defined\n   * @param {number} x\n   * @param {number} y\n   */\n\n\n  function elementPrototypeScrollToFallback(x, y) {\n    return elementPrototypeScrollFallback.call(this, x, y);\n  }\n  /**\n   * A fallback if Element.prototype.scrollBy is not defined\n   * @param {number} x\n   * @param {number} y\n   */\n\n\n  function elementPrototypeScrollByFallback(x, y) {\n    this.__adjustingScrollPosition = true;\n    this.scrollLeft += x;\n    this.scrollTop += y;\n    delete this.__adjustingScrollPosition;\n  }\n  /**\n   * Gets the original non-patched prototype method for the given kind\n   * @param {ScrollMethodName} kind\n   * @param {Element|Window} element\n   * @return {Function}\n   */\n\n\n  function getOriginalScrollMethodForKind(kind, element) {\n    switch (kind) {\n      case \"scroll\":\n        if (element instanceof Element) {\n          if (ELEMENT_ORIGINAL_SCROLL != null) {\n            return ELEMENT_ORIGINAL_SCROLL;\n          } else {\n            return elementPrototypeScrollFallback;\n          }\n        } else {\n          return WINDOW_ORIGINAL_SCROLL;\n        }\n\n      case \"scrollBy\":\n        if (element instanceof Element) {\n          if (ELEMENT_ORIGINAL_SCROLL_BY != null) {\n            return ELEMENT_ORIGINAL_SCROLL_BY;\n          } else {\n            return elementPrototypeScrollByFallback;\n          }\n        } else {\n          return WINDOW_ORIGINAL_SCROLL_BY;\n        }\n\n      case \"scrollTo\":\n        if (element instanceof Element) {\n          if (ELEMENT_ORIGINAL_SCROLL_TO != null) {\n            return ELEMENT_ORIGINAL_SCROLL_TO;\n          } else {\n            return elementPrototypeScrollToFallback;\n          }\n        } else {\n          return WINDOW_ORIGINAL_SCROLL_TO;\n        }\n\n    }\n  }\n  /**\n   * Gets the Smooth Scroll Options to use for the step function\n   * @param {Element|Window} element\n   * @param {number} x\n   * @param {number} y\n   * @param {ScrollMethodName} kind\n   * @returns {ISmoothScrollOptions}\n   */\n\n\n  function getSmoothScrollOptions(element, x, y, kind) {\n    var startTime = now();\n\n    if (!(element instanceof Element)) {\n      // Use window as the scroll container\n      var scrollX_1 = window.scrollX,\n          pageXOffset_1 = window.pageXOffset,\n          scrollY_1 = window.scrollY,\n          pageYOffset_1 = window.pageYOffset;\n      var startX = scrollX_1 == null || scrollX_1 === 0 ? pageXOffset_1 : scrollX_1;\n      var startY = scrollY_1 == null || scrollY_1 === 0 ? pageYOffset_1 : scrollY_1;\n      return {\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        endX: Math.floor(kind === \"scrollBy\" ? startX + x : x),\n        endY: Math.floor(kind === \"scrollBy\" ? startY + y : y),\n        method: getOriginalScrollMethodForKind(\"scrollTo\", window).bind(window),\n        scroller: getScrollingElement()\n      };\n    } else {\n      var scrollLeft = element.scrollLeft,\n          scrollTop = element.scrollTop;\n      var startX = scrollLeft;\n      var startY = scrollTop;\n      return {\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        endX: Math.floor(kind === \"scrollBy\" ? startX + x : x),\n        endY: Math.floor(kind === \"scrollBy\" ? startY + y : y),\n        method: getOriginalScrollMethodForKind(\"scrollTo\", element).bind(element),\n        scroller: element\n      };\n    }\n  }\n  /**\n   * Ensures that the given value is numeric\n   * @param {number} value\n   * @return {number}\n   */\n\n\n  function ensureNumeric(value) {\n    if (value == null) return 0;else if (typeof value === \"number\") {\n      return value;\n    } else if (typeof value === \"string\") {\n      return parseFloat(value);\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Returns true if the given value is some ScrollToOptions\n   * @param {number | ScrollToOptions} value\n   * @return {value is ScrollToOptions}\n   */\n\n\n  function isScrollToOptions(value) {\n    return value != null && typeof value === \"object\";\n  }\n  /**\n   * Handles a scroll method\n   * @param {Element|Window} element\n   * @param {ScrollMethodName} kind\n   * @param {number | ScrollToOptions} optionsOrX\n   * @param {number} y\n   */\n\n\n  function handleScrollMethod(element, kind, optionsOrX, y) {\n    onScrollWithOptions(getScrollToOptionsWithValidation(optionsOrX, y), element, kind);\n  }\n  /**\n   * Invoked when a 'ScrollToOptions' dict is provided to 'scroll()' as the first argument\n   * @param {ScrollToOptions} options\n   * @param {Element|Window} element\n   * @param {ScrollMethodName} kind\n   */\n\n\n  function onScrollWithOptions(options, element, kind) {\n    var behavior = getScrollBehavior(element, options); // If the behavior is 'auto' apply instantaneous scrolling\n\n    if (behavior == null || behavior === \"auto\") {\n      getOriginalScrollMethodForKind(kind, element).call(element, options.left, options.top);\n    } else {\n      smoothScroll(getSmoothScrollOptions(element, options.left, options.top, kind));\n    }\n  }\n  /**\n   * Normalizes the given scroll coordinates\n   * @param {number?} x\n   * @param {number?} y\n   * @return {Required<Pick<ScrollToOptions, \"top\" | \"left\">>}\n   */\n\n\n  function normalizeScrollCoordinates(x, y) {\n    return {\n      left: ensureNumeric(x),\n      top: ensureNumeric(y)\n    };\n  }\n  /**\n   * Gets ScrollToOptions based on the given arguments. Will throw if validation fails\n   * @param {number | ScrollToOptions} optionsOrX\n   * @param {number} y\n   * @return {Required<ScrollToOptions>}\n   */\n\n\n  function getScrollToOptionsWithValidation(optionsOrX, y) {\n    // If only one argument is given, and it isn't an options object, throw a TypeError\n    if (y === undefined && !isScrollToOptions(optionsOrX)) {\n      throw new TypeError(\"Failed to execute 'scroll' on 'Element': parameter 1 ('options') is not an object.\");\n    } // Scroll based on the primitive values given as arguments\n\n\n    if (!isScrollToOptions(optionsOrX)) {\n      return _assign(_assign({}, normalizeScrollCoordinates(optionsOrX, y)), {\n        behavior: \"auto\"\n      });\n    } // Scroll based on the received options object\n    else {\n        return _assign(_assign({}, normalizeScrollCoordinates(optionsOrX.left, optionsOrX.top)), {\n          behavior: optionsOrX.behavior == null ? \"auto\" : optionsOrX.behavior\n        });\n      }\n  }\n  /**\n   * Patches the 'scroll' method on the Element prototype\n   */\n\n\n  function patchElementScroll() {\n    Element.prototype.scroll = function (optionsOrX, y) {\n      handleScrollMethod(this, \"scroll\", optionsOrX, y);\n    };\n  }\n  /**\n   * Patches the 'scrollBy' method on the Element prototype\n   */\n\n\n  function patchElementScrollBy() {\n    Element.prototype.scrollBy = function (optionsOrX, y) {\n      handleScrollMethod(this, \"scrollBy\", optionsOrX, y);\n    };\n  }\n  /**\n   * Patches the 'scrollTo' method on the Element prototype\n   */\n\n\n  function patchElementScrollTo() {\n    Element.prototype.scrollTo = function (optionsOrX, y) {\n      handleScrollMethod(this, \"scrollTo\", optionsOrX, y);\n    };\n  }\n  /**\n   * Patches the 'scroll' method on the Window prototype\n   */\n\n\n  function patchWindowScroll() {\n    window.scroll = function (optionsOrX, y) {\n      handleScrollMethod(this, \"scroll\", optionsOrX, y);\n    };\n  }\n  /**\n   * Patches the 'scrollBy' method on the Window prototype\n   */\n\n\n  function patchWindowScrollBy() {\n    window.scrollBy = function (optionsOrX, y) {\n      handleScrollMethod(this, \"scrollBy\", optionsOrX, y);\n    };\n  }\n  /**\n   * Patches the 'scrollTo' method on the Window prototype\n   */\n\n\n  function patchWindowScrollTo() {\n    window.scrollTo = function (optionsOrX, y) {\n      handleScrollMethod(this, \"scrollTo\", optionsOrX, y);\n    };\n  } // tslint:disable:no-any\n\n  /**\n   * Gets the parent of an element, taking into account DocumentFragments, ShadowRoots, as well as the root context (window)\n   * @param {EventTarget} currentElement\n   * @returns {EventTarget | null}\n   */\n\n\n  function getParent(currentElement) {\n    if (\"nodeType\" in currentElement && currentElement.nodeType === 1) {\n      return currentElement.parentNode;\n    }\n\n    if (\"ShadowRoot\" in window && currentElement instanceof window.ShadowRoot) {\n      return currentElement.host;\n    } else if (currentElement === document) {\n      return window;\n    } else if (currentElement instanceof Node) return currentElement.parentNode;\n\n    return null;\n  }\n  /**\n   * Returns true if the given overflow property represents a scrollable overflow value\n   * @param {string | null} overflow\n   * @return {boolean}\n   */\n\n\n  function canOverflow(overflow) {\n    return overflow !== \"visible\" && overflow !== \"clip\";\n  }\n  /**\n   * Returns true if the given element is scrollable\n   * @param {Element} element\n   * @return {boolean}\n   */\n\n\n  function isScrollable(element) {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n      var style = getComputedStyle(element, null);\n      return canOverflow(style.overflowY) || canOverflow(style.overflowX);\n    }\n\n    return false;\n  }\n  /**\n   * Finds the nearest ancestor of an element that can scroll\n   * @param {Element} target\n   * @returns {Element|Window?}\n   */\n\n\n  function findNearestAncestorsWithScrollBehavior(target) {\n    var currentElement = target;\n    var scrollingElement = getScrollingElement();\n\n    while (currentElement != null) {\n      var behavior = getScrollBehavior(currentElement);\n\n      if (behavior != null && (currentElement === scrollingElement || isScrollable(currentElement))) {\n        return [currentElement, behavior];\n      }\n\n      var parent_1 = getParent(currentElement);\n      currentElement = parent_1;\n    } // No such element could be found. Start over, but this time find the nearest ancestor that can simply scroll\n\n\n    currentElement = target;\n\n    while (currentElement != null) {\n      if (currentElement === scrollingElement || isScrollable(currentElement)) {\n        return [currentElement, \"auto\"];\n      }\n\n      var parent_2 = getParent(currentElement);\n      currentElement = parent_2;\n    } // Default to the scrolling element\n\n\n    return [scrollingElement, \"auto\"];\n  } // tslint:disable:no-any\n\n  /**\n   * Finds the nearest root from an element\n   * @param {Element} target\n   * @returns {Document|ShadowRoot}\n   */\n\n\n  function findNearestRoot(target) {\n    var currentElement = target;\n\n    while (currentElement != null) {\n      if (\"ShadowRoot\" in window && currentElement instanceof window.ShadowRoot) {\n        // Assume this is a ShadowRoot\n        return currentElement;\n      }\n\n      var parent_1 = getParent(currentElement);\n\n      if (parent_1 === currentElement) {\n        return document;\n      }\n\n      currentElement = parent_1;\n    }\n\n    return document;\n  }\n  /**\n   * Gets the origin of the given Location or HTMLAnchorElement if available in the runtime, and otherwise shims it. (it's a one-liner)\n   * @returns {string}\n   */\n\n\n  function getLocationOrigin(locationLike) {\n    if (locationLike === void 0) {\n      locationLike = location;\n    }\n\n    if (\"origin\" in locationLike && locationLike.origin != null) {\n      return locationLike.origin;\n    }\n\n    var port = locationLike.port != null && locationLike.port.length > 0 ? \":\" + locationLike.port : \"\";\n\n    if (locationLike.protocol === \"http:\" && port === \":80\") {\n      port = \"\";\n    } else if (locationLike.protocol === \"https:\" && port === \":443\") {\n      port = \"\";\n    }\n\n    return locationLike.protocol + \"//\" + locationLike.hostname + port;\n  }\n  /**\n   * A Regular expression that matches id's of the form \"#[digit]\"\n   * @type {RegExp}\n   */\n\n\n  var ID_WITH_LEADING_DIGIT_REGEXP = /^#\\d/;\n  /**\n   * Catches anchor navigation to IDs within the same root and ensures that they can be smooth-scrolled\n   * if the scroll behavior is smooth in the first rooter within that context\n   */\n\n  function catchNavigation() {\n    // Listen for 'click' events globally\n    window.addEventListener(\"click\", function (e) {\n      // Only work with trusted events on HTMLAnchorElements\n      if (!e.isTrusted || !(e.target instanceof HTMLAnchorElement)) return;\n      var _a = e.target,\n          pathname = _a.pathname,\n          search = _a.search,\n          hash = _a.hash;\n      var pointsToCurrentPage = getLocationOrigin(e.target) === getLocationOrigin(location) && pathname === location.pathname && search === location.search; // Only work with HTMLAnchorElements that navigates to a specific ID on the current page\n\n      if (!pointsToCurrentPage || hash == null || hash.length < 1) {\n        return;\n      } // Find the nearest root, whether it be a ShadowRoot or the document itself\n\n\n      var root = findNearestRoot(e.target); // Attempt to match the selector from that root. querySelector' doesn't support IDs that start with a digit, so work around that limitation\n\n      var elementMatch = hash.match(ID_WITH_LEADING_DIGIT_REGEXP) != null ? root.getElementById(hash.slice(1)) : root.querySelector(hash); // If no selector could be found, don't proceed\n\n      if (elementMatch == null) return; // Find the nearest ancestor that can be scrolled\n\n      var _b = __read(findNearestAncestorsWithScrollBehavior(elementMatch), 2),\n          behavior = _b[1]; // If the behavior isn't smooth, don't proceed\n\n\n      if (behavior !== \"smooth\") return; // Otherwise, first prevent the default action.\n\n      e.preventDefault(); // Now, scroll to the element with that ID\n\n      elementMatch.scrollIntoView({\n        behavior: behavior\n      });\n    });\n  }\n\n  var ELEMENT_ORIGINAL_SCROLL_INTO_VIEW = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollIntoView;\n  /**\n   * The majority of this file is based on https://github.com/stipsan/compute-scroll-into-view (MIT license),\n   * but has been rewritten to accept a scroller as an argument.\n   */\n\n  /**\n   * Find out which edge to align against when logical scroll position is \"nearest\"\n   * Interesting fact: \"nearest\" works similarly to \"if-needed\", if the element is fully visible it will not scroll it\n   *\n   * Legends:\n   *      \n   *  target    frame\n   *      \n   */\n\n  function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          \n     *        \n     *            \n     *                    do nothing\n     *            \n     *        \n     *          \n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *         \n     *   \n     *                    do nothing\n     *   \n     *         \n     */\n    if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {\n      return 0;\n    }\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          \n     *                 \n     *                         \n     *  from             to    \n     *\n     *                     \n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *                   \n     *                             \n     *  from         to      \n     *                           \n     *                 \n     *                         \n     *            \n     *          \n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *                       \n     *                   \n     *                            \n     *                   \n     *                       \n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *                       \n     *           \n     *                              \n     *           \n     *                       \n     */\n\n\n    if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {\n      return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;\n    }\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *                     \n     *\n     *  from             to    \n     *                         \n     *                 \n     *          \n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          \n     *            \n     *                         \n     *                 \n     *                           \n     *  from         to      \n     *                             \n     *                   \n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *                           \n     *             \n     *                                \n     *             \n     *                           \n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *                           \n     *                             \n     *                                \n     *                             \n     *                           \n     *\n     */\n\n\n    if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {\n      return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;\n    }\n\n    return 0;\n  }\n\n  function computeScrollIntoView(target, scroller, options) {\n    var block = options.block,\n        inline = options.inline; // Used to handle the top most element that can be scrolled\n\n    var scrollingElement = getScrollingElement(); // Support pinch-zooming properly, making sure elements scroll into the visual viewport\n    // Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height\n    // and viewport dimensions on window.innerWidth/Height\n    // https://www.quirksmode.org/mobile/viewports2.html\n    // https://bokand.github.io/viewport/index.html\n\n    var viewportWidth = window.visualViewport != null ? visualViewport.width : innerWidth;\n    var viewportHeight = window.visualViewport != null ? visualViewport.height : innerHeight;\n    var viewportX = window.scrollX != null ? window.scrollX : window.pageXOffset;\n    var viewportY = window.scrollY != null ? window.scrollY : window.pageYOffset;\n\n    var _a = target.getBoundingClientRect(),\n        targetHeight = _a.height,\n        targetWidth = _a.width,\n        targetTop = _a.top,\n        targetRight = _a.right,\n        targetBottom = _a.bottom,\n        targetLeft = _a.left; // These values mutate as we loop through and generate scroll coordinates\n\n\n    var targetBlock = block === \"start\" || block === \"nearest\" ? targetTop : block === \"end\" ? targetBottom : targetTop + targetHeight / 2; // block === 'center\n\n    var targetInline = inline === \"center\" ? targetLeft + targetWidth / 2 : inline === \"end\" ? targetRight : targetLeft; // inline === 'start || inline === 'nearest\n\n    var _b = scroller.getBoundingClientRect(),\n        height = _b.height,\n        width = _b.width,\n        top = _b.top,\n        right = _b.right,\n        bottom = _b.bottom,\n        left = _b.left;\n\n    var frameStyle = getComputedStyle(scroller);\n    var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);\n    var borderTop = parseInt(frameStyle.borderTopWidth, 10);\n    var borderRight = parseInt(frameStyle.borderRightWidth, 10);\n    var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);\n    var blockScroll = 0;\n    var inlineScroll = 0; // The property existance checks for offset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here\n    // @TODO find out if the \"as HTMLElement\" overrides can be dropped\n\n    var scrollbarWidth = \"offsetWidth\" in scroller ? scroller.offsetWidth - scroller.clientWidth - borderLeft - borderRight : 0;\n    var scrollbarHeight = \"offsetHeight\" in scroller ? scroller.offsetHeight - scroller.clientHeight - borderTop - borderBottom : 0;\n\n    if (scrollingElement === scroller) {\n      // Handle viewport logic (document.documentElement or document.body)\n      if (block === \"start\") {\n        blockScroll = targetBlock;\n      } else if (block === \"end\") {\n        blockScroll = targetBlock - viewportHeight;\n      } else if (block === \"nearest\") {\n        blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);\n      } else {\n        // block === 'center' is the default\n        blockScroll = targetBlock - viewportHeight / 2;\n      }\n\n      if (inline === \"start\") {\n        inlineScroll = targetInline;\n      } else if (inline === \"center\") {\n        inlineScroll = targetInline - viewportWidth / 2;\n      } else if (inline === \"end\") {\n        inlineScroll = targetInline - viewportWidth;\n      } else {\n        // inline === 'nearest' is the default\n        inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);\n      } // Apply scroll position offsets and ensure they are within bounds\n      // @TODO add more test cases to cover this 100%\n\n\n      blockScroll = Math.max(0, blockScroll + viewportY);\n      inlineScroll = Math.max(0, inlineScroll + viewportX);\n    } else {\n      // Handle each scrolling frame that might exist between the target and the viewport\n      if (block === \"start\") {\n        blockScroll = targetBlock - top - borderTop;\n      } else if (block === \"end\") {\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;\n      } else if (block === \"nearest\") {\n        blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);\n      } else {\n        // block === 'center' is the default\n        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;\n      }\n\n      if (inline === \"start\") {\n        inlineScroll = targetInline - left - borderLeft;\n      } else if (inline === \"center\") {\n        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;\n      } else if (inline === \"end\") {\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth;\n      } else {\n        // inline === 'nearest' is the default\n        inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);\n      }\n\n      var scrollLeft = scroller.scrollLeft,\n          scrollTop = scroller.scrollTop; // Ensure scroll coordinates are not out of bounds while applying scroll offsets\n\n      blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, scroller.scrollHeight - height + scrollbarHeight));\n      inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, scroller.scrollWidth - width + scrollbarWidth));\n    }\n\n    return {\n      top: blockScroll,\n      left: inlineScroll\n    };\n  }\n  /**\n   * Patches the 'scrollIntoView' method on the Element prototype\n   */\n\n\n  function patchElementScrollIntoView() {\n    Element.prototype.scrollIntoView = function (arg) {\n      var normalizedOptions = arg == null || arg === true ? {\n        block: \"start\",\n        inline: \"nearest\"\n      } : arg === false ? {\n        block: \"end\",\n        inline: \"nearest\"\n      } : arg; // Find the nearest ancestor that can be scrolled\n\n      var _a = __read(findNearestAncestorsWithScrollBehavior(this), 2),\n          ancestorWithScroll = _a[0],\n          ancestorWithScrollBehavior = _a[1];\n\n      var behavior = normalizedOptions.behavior != null ? normalizedOptions.behavior : ancestorWithScrollBehavior; // If the behavior isn't smooth, simply invoke the original implementation and do no more\n\n      if (behavior !== \"smooth\") {\n        // Assert that 'scrollIntoView' is actually defined\n        if (ELEMENT_ORIGINAL_SCROLL_INTO_VIEW != null) {\n          ELEMENT_ORIGINAL_SCROLL_INTO_VIEW.call(this, normalizedOptions);\n        } // Otherwise, invoke 'scrollTo' instead and provide the scroll coordinates\n        else {\n            var _b = computeScrollIntoView(this, ancestorWithScroll, normalizedOptions),\n                top_1 = _b.top,\n                left = _b.left;\n\n            getOriginalScrollMethodForKind(\"scrollTo\", this).call(this, left, top_1);\n          }\n\n        return;\n      }\n\n      ancestorWithScroll.scrollTo(_assign({\n        behavior: behavior\n      }, computeScrollIntoView(this, ancestorWithScroll, normalizedOptions)));\n    }; // On IE11, HTMLElement has its own declaration of scrollIntoView and does not inherit this from the prototype chain, so we'll need to patch that one too.\n\n\n    if (HTMLElement.prototype.scrollIntoView != null && HTMLElement.prototype.scrollIntoView !== Element.prototype.scrollIntoView) {\n      HTMLElement.prototype.scrollIntoView = Element.prototype.scrollIntoView;\n    }\n  }\n\n  var ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT ? undefined : Object.getOwnPropertyDescriptor(Element.prototype, \"scrollTop\").set;\n  /**\n   * Patches the 'scrollTop' property descriptor on the Element prototype\n   */\n\n  function patchElementScrollTop() {\n    Object.defineProperty(Element.prototype, \"scrollTop\", {\n      set: function set(scrollTop) {\n        if (this.__adjustingScrollPosition) {\n          return ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR.call(this, scrollTop);\n        }\n\n        handleScrollMethod(this, \"scrollTo\", this.scrollLeft, scrollTop);\n        return scrollTop;\n      }\n    });\n  }\n\n  var ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT ? undefined : Object.getOwnPropertyDescriptor(Element.prototype, \"scrollLeft\").set;\n  /**\n   * Patches the 'scrollLeft' property descriptor on the Element prototype\n   */\n\n  function patchElementScrollLeft() {\n    Object.defineProperty(Element.prototype, \"scrollLeft\", {\n      set: function set(scrollLeft) {\n        if (this.__adjustingScrollPosition) {\n          return ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR.call(this, scrollLeft);\n        }\n\n        handleScrollMethod(this, \"scrollTo\", scrollLeft, this.scrollTop);\n        return scrollLeft;\n      }\n    });\n  }\n  /**\n   * Applies the polyfill\n   */\n\n\n  function patch() {\n    // Element.prototype methods\n    patchElementScroll();\n    patchElementScrollBy();\n    patchElementScrollTo();\n    patchElementScrollIntoView(); // Element.prototype descriptors\n\n    patchElementScrollLeft();\n    patchElementScrollTop(); // window methods\n\n    patchWindowScroll();\n    patchWindowScrollBy();\n    patchWindowScrollTo(); // Navigation\n\n    catchNavigation();\n  }\n  /**\n   * Is true if the browser natively supports the Element.prototype.[scroll|scrollTo|scrollBy|scrollIntoView] methods\n   * @type {boolean}\n   */\n\n\n  var SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS = UNSUPPORTED_ENVIRONMENT ? false : \"scroll\" in Element.prototype && \"scrollTo\" in Element.prototype && \"scrollBy\" in Element.prototype && \"scrollIntoView\" in Element.prototype;\n\n  if (!UNSUPPORTED_ENVIRONMENT && (!SUPPORTS_SCROLL_BEHAVIOR || !SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS)) {\n    patch();\n  }\n})();\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["../src/support/unsupported-environment.ts","../src/support/supports-scroll-behavior.ts","../node_modules/tslib/tslib.es6.js","../src/util/scrolling-element.ts","../src/util/attribute.ts","../src/util/get-scroll-behavior.ts","../src/util/easing.ts","../src/util/disable-scroll-snap.ts","../src/smooth-scroll/smooth-scroll/smooth-scroll.ts","../src/util/now.ts","../src/original/element/scroll.ts","../src/original/window/scroll.ts","../src/original/element/scroll-by.ts","../src/original/window/scroll-by.ts","../src/original/element/scroll-to.ts","../src/original/window/scroll-to.ts","../src/scroll-method/get-original-scroll-method-for-kind.ts","../src/smooth-scroll/get-smooth-scroll-options/get-smooth-scroll-options.ts","../src/util/ensure-numeric.ts","../src/util/is-scroll-to-options.ts","../src/patch/shared.ts","../src/patch/element/scroll.ts","../src/patch/element/scroll-by.ts","../src/patch/element/scroll-to.ts","../src/patch/window/scroll.ts","../src/patch/window/scroll-by.ts","../src/patch/window/scroll-to.ts","../src/util/get-parent.ts","../src/util/find-nearest-ancestor-with-scroll-behavior.ts","../src/util/find-nearest-root.ts","../src/util/get-location-origin.ts","../src/patch/anchor/catch-navigation.ts","../src/original/element/scroll-into-view.ts","../src/patch/element/compute-scroll-into-view.ts","../src/patch/element/scroll-into-view.ts","../src/original/element/scroll-top.ts","../src/patch/element/scroll-top.ts","../src/original/element/scroll-left.ts","../src/patch/element/scroll-left.ts","../src/patch/patch.ts","../src/support/supports-element-prototype-scroll-methods.ts","../src/index.ts"],"names":[],"mappings":"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","file":"x","sourcesContent":["export const UNSUPPORTED_ENVIRONMENT = typeof window === \"undefined\";\n","import {UNSUPPORTED_ENVIRONMENT} from \"./unsupported-environment\";\n\n/**\n * Is true if the browser natively supports the 'scroll-behavior' CSS-property.\n * @type {boolean}\n */\nexport const SUPPORTS_SCROLL_BEHAVIOR = UNSUPPORTED_ENVIRONMENT ? false : \"scrollBehavior\" in document.documentElement.style;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export function getScrollingElement(): HTMLElement {\n\tif (document.scrollingElement != null) {\n\t\treturn document.scrollingElement as HTMLElement;\n\t} else {\n\t\treturn document.documentElement;\n\t}\n}\n","const STYLE_ATTRIBUTE_PROPERTY_NAME = \"scroll-behavior\";\nconst STYLE_ATTRIBUTE_PROPERTY_REGEXP = new RegExp(`${STYLE_ATTRIBUTE_PROPERTY_NAME}:\\\\s*([^;]*)`);\n\n/**\n * Given an Element, this function appends the given ScrollBehavior CSS property value to the elements' 'style' attribute.\n * If it doesnt already have one, it will add it.\n * @param {Element} element\n * @param {ScrollBehavior} behavior\n */\nexport function appendScrollBehaviorToStyleAttribute(element: Element, behavior: ScrollBehavior): void {\n\tconst addition = `${STYLE_ATTRIBUTE_PROPERTY_NAME}:${behavior}`;\n\tlet attributeValue = element.getAttribute(\"style\");\n\tif (attributeValue == null || attributeValue === \"\") {\n\t\telement.setAttribute(\"style\", addition);\n\t\treturn;\n\t}\n\n\t// The style attribute may already include a 'scroll-behavior:<something>' in which case that should be replaced\n\tconst existingValueForProperty = parseScrollBehaviorFromStyleAttribute(element);\n\tif (existingValueForProperty != null) {\n\t\tconst replacementProperty = `${STYLE_ATTRIBUTE_PROPERTY_NAME}:${existingValueForProperty}`;\n\t\t// Replace the variant that ends with a semi-colon which it may\n\t\tattributeValue = attributeValue.replace(`${replacementProperty};`, \"\");\n\t\t// Replace the variant that *doesn't* end with a semi-colon\n\t\tattributeValue = attributeValue.replace(replacementProperty, \"\");\n\t}\n\n\t// Now, append the behavior to the string.\n\telement.setAttribute(\"style\", attributeValue.endsWith(\";\") ? `${attributeValue}${addition}` : `;${attributeValue}${addition}`);\n}\n\n/**\n * Given an Element, this function attempts to parse its 'style' attribute (if it has one)' to extract\n * a value for the 'scroll-behavior' CSS property (if it is given within that style attribute)\n * @param {Element} element\n * @returns {ScrollBehavior?}\n */\nexport function parseScrollBehaviorFromStyleAttribute(element: Element): ScrollBehavior | undefined {\n\tconst styleAttributeValue = element.getAttribute(\"style\");\n\tif (styleAttributeValue != null && styleAttributeValue.includes(STYLE_ATTRIBUTE_PROPERTY_NAME)) {\n\t\tconst match = styleAttributeValue.match(STYLE_ATTRIBUTE_PROPERTY_REGEXP);\n\t\tif (match != null) {\n\t\t\tconst [, behavior] = match;\n\t\t\tif (behavior != null && behavior !== \"\") {\n\t\t\t\treturn behavior as ScrollBehavior;\n\t\t\t}\n\t\t}\n\t}\n\treturn undefined;\n}\n","import {getScrollingElement} from \"./scrolling-element\";\nimport {parseScrollBehaviorFromStyleAttribute} from \"./attribute\";\n\nconst styleDeclarationPropertyName = \"scrollBehavior\" as keyof CSSStyleDeclaration;\nexport type ScrollBehaviorRawValue = ScrollBehavior | null | \"\";\n\n/**\n * Determines the scroll behavior to use, depending on the given ScrollOptions and the position of the Element\n * within the DOM\n * @param {Element|HTMLElement|Window} inputTarget\n * @param {ScrollOptions} [options]\n * @returns {ScrollBehavior}\n */\nexport function getScrollBehavior(inputTarget: Element | HTMLElement | Window, options?: ScrollOptions): ScrollBehavior | undefined {\n\t// If the given 'behavior' is 'smooth', apply smooth scrolling no matter what\n\tif (options != null && options.behavior === \"smooth\") return \"smooth\";\n\n\tconst target: HTMLElement = \"style\" in inputTarget ? inputTarget : getScrollingElement();\n\n\tlet value: ScrollBehavior | undefined;\n\n\tif (\"style\" in target) {\n\t\t// Check if scroll-behavior is set as a property on the CSSStyleDeclaration\n\t\tconst scrollBehaviorPropertyValue = target.style[styleDeclarationPropertyName] as ScrollBehaviorRawValue;\n\t\t// Return it if it is given and has a proper value\n\t\tif (scrollBehaviorPropertyValue != null && scrollBehaviorPropertyValue !== \"\") {\n\t\t\tvalue = scrollBehaviorPropertyValue;\n\t\t}\n\t}\n\n\tif (value == null) {\n\t\tconst attributeValue = target.getAttribute(\"scroll-behavior\");\n\t\tif (attributeValue != null && attributeValue !== \"\") {\n\t\t\tvalue = attributeValue as ScrollBehavior;\n\t\t}\n\t}\n\n\tif (value == null) {\n\t\t// Otherwise, check if it is set as an inline style\n\t\tvalue = parseScrollBehaviorFromStyleAttribute(target);\n\t}\n\n\tif (value == null) {\n\t\t// Take the computed style for the element and see if it contains a specific 'scroll-behavior' value\n\t\tconst computedStyle = getComputedStyle(target);\n\t\tconst computedStyleValue = computedStyle.getPropertyValue(\"scrollBehavior\") as ScrollBehaviorRawValue;\n\t\tif (computedStyleValue != null && computedStyleValue !== \"\") {\n\t\t\tvalue = computedStyleValue;\n\t\t}\n\t}\n\n\t// In all other cases, use the value from the CSSOM\n\treturn value;\n}\n","const HALF = 0.5;\n\n/**\n * The easing function to use when applying the smooth scrolling\n * @param {number} k\n * @returns {number}\n */\nexport function ease(k: number) {\n\treturn HALF * (1 - Math.cos(Math.PI * k));\n}\n","import {ScrollSnappable} from \"./scroll-snappable\";\nimport {SUPPORTS_SCROLL_BEHAVIOR} from \"../support/supports-scroll-behavior\";\nimport {appendScrollBehaviorToStyleAttribute, parseScrollBehaviorFromStyleAttribute} from \"./attribute\";\nimport {getScrollingElement} from \"./scrolling-element\";\n\nexport interface DisableScrollSnapResult {\n\treset(): void;\n}\n\nexport interface DisableScrollSnapReleaser {\n\tcachedScrollSnapValue: string | null;\n\tcachedScrollBehaviorStyleAttributeValue: ScrollBehavior | undefined;\n\tsecondaryScroller: ScrollSnappable | undefined;\n\tsecondaryScrollerCachedScrollSnapValue: string | null | undefined;\n\tsecondaryScrollerCachedScrollBehaviorStyleAttributeValue: ScrollBehavior | undefined;\n\trelease(): void;\n}\n\nconst NOOP: DisableScrollSnapResult = {\n\treset: () => {}\n};\n\nconst map = typeof WeakMap === \"undefined\" ? undefined : new WeakMap<ScrollSnappable, DisableScrollSnapReleaser>();\n\nexport function disableScrollSnap(scroller: ScrollSnappable): DisableScrollSnapResult {\n\t// If scroll-behavior is natively supported, or if there is no native WeakMap support, there's no need for this fix\n\tif (SUPPORTS_SCROLL_BEHAVIOR || map == null) {\n\t\treturn NOOP;\n\t}\n\n\tconst scrollingElement = getScrollingElement();\n\n\tlet cachedScrollSnapValue: string | null;\n\tlet cachedScrollBehaviorStyleAttributeValue: ScrollBehavior | undefined;\n\tlet secondaryScroller: ScrollSnappable | undefined;\n\tlet secondaryScrollerCachedScrollSnapValue: string | null | undefined;\n\tlet secondaryScrollerCachedScrollBehaviorStyleAttributeValue: ScrollBehavior | undefined;\n\tconst existingResult = map.get(scroller);\n\tif (existingResult != null) {\n\t\tcachedScrollSnapValue = existingResult.cachedScrollSnapValue;\n\t\tcachedScrollBehaviorStyleAttributeValue = existingResult.cachedScrollBehaviorStyleAttributeValue;\n\t\tsecondaryScroller = existingResult.secondaryScroller;\n\t\tsecondaryScrollerCachedScrollSnapValue = existingResult.secondaryScrollerCachedScrollSnapValue;\n\t\tsecondaryScrollerCachedScrollBehaviorStyleAttributeValue = existingResult.secondaryScrollerCachedScrollBehaviorStyleAttributeValue;\n\t\texistingResult.release();\n\t} else {\n\t\tcachedScrollSnapValue = scroller.style.scrollSnapType === \"\" ? null : scroller.style.scrollSnapType;\n\t\tcachedScrollBehaviorStyleAttributeValue = parseScrollBehaviorFromStyleAttribute(scroller);\n\t\tsecondaryScroller = scroller === scrollingElement && scrollingElement !== document.body ? (document.body as ScrollSnappable) : undefined;\n\t\tsecondaryScrollerCachedScrollSnapValue =\n\t\t\tsecondaryScroller == null ? undefined : secondaryScroller.style.scrollSnapType === \"\" ? null : secondaryScroller.style.scrollSnapType;\n\t\tsecondaryScrollerCachedScrollBehaviorStyleAttributeValue =\n\t\t\tsecondaryScroller == null ? undefined : parseScrollBehaviorFromStyleAttribute(secondaryScroller);\n\n\t\tconst cachedComputedScrollSnapValue = getComputedStyle(scroller).getPropertyValue(\"scroll-snap-type\");\n\t\tconst secondaryScrollerCachedComputedScrollSnapValue =\n\t\t\tsecondaryScroller == null ? undefined : getComputedStyle(secondaryScroller).getPropertyValue(\"scroll-snap-type\");\n\n\t\t// If it just so happens that there actually isn't any scroll snapping going on, there's no point in performing any additional work here.\n\t\tif (cachedComputedScrollSnapValue === \"none\" && secondaryScrollerCachedComputedScrollSnapValue === \"none\") {\n\t\t\treturn NOOP;\n\t\t}\n\t}\n\n\tscroller.style.scrollSnapType = \"none\";\n\tif (secondaryScroller !== undefined) {\n\t\tsecondaryScroller.style.scrollSnapType = \"none\";\n\t}\n\tif (cachedScrollBehaviorStyleAttributeValue !== undefined) {\n\t\tappendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);\n\t}\n\n\tif (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {\n\t\tappendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);\n\t}\n\n\tlet hasReleased = false;\n\n\tconst eventTarget = scroller === scrollingElement ? window : scroller;\n\n\tfunction release() {\n\t\teventTarget.removeEventListener(\"scroll\", resetHandler);\n\t\tif (map != null) {\n\t\t\tmap.delete(scroller);\n\t\t}\n\t\thasReleased = true;\n\t}\n\n\tfunction resetHandler() {\n\t\tscroller.style.scrollSnapType = cachedScrollSnapValue;\n\n\t\tif (secondaryScroller != null && secondaryScrollerCachedScrollSnapValue !== undefined) {\n\t\t\tsecondaryScroller.style.scrollSnapType = secondaryScrollerCachedScrollSnapValue;\n\t\t}\n\n\t\tif (cachedScrollBehaviorStyleAttributeValue !== undefined) {\n\t\t\tappendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);\n\t\t}\n\n\t\tif (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {\n\t\t\tappendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);\n\t\t}\n\n\t\trelease();\n\t}\n\n\tfunction reset() {\n\t\tsetTimeout(() => {\n\t\t\tif (hasReleased) return;\n\t\t\teventTarget.addEventListener(\"scroll\", resetHandler);\n\t\t});\n\t}\n\n\tmap.set(scroller, {\n\t\trelease,\n\t\tcachedScrollSnapValue,\n\t\tcachedScrollBehaviorStyleAttributeValue,\n\t\tsecondaryScroller,\n\t\tsecondaryScrollerCachedScrollSnapValue,\n\t\tsecondaryScrollerCachedScrollBehaviorStyleAttributeValue\n\t});\n\n\treturn {\n\t\treset\n\t};\n}\n","import {ISmoothScrollOptions} from \"../smooth-scroll-options/i-smooth-scroll-options\";\nimport {ease} from \"../../util/easing\";\nimport {disableScrollSnap, DisableScrollSnapResult} from \"../../util/disable-scroll-snap\";\n\n/**\n * The duration of a smooth scroll\n * @type {number}\n */\nconst SCROLL_TIME = 15000;\n\n/**\n * Performs a smooth repositioning of the scroll\n * @param {ISmoothScrollOptions} options\n */\nexport function smoothScroll(options: ISmoothScrollOptions): void {\n\tconst {startTime, startX, startY, endX, endY, method, scroller} = options;\n\n\tlet timeLapsed = 0;\n\tlet start: number | undefined;\n\n\tconst distanceX = endX - startX;\n\tconst distanceY = endY - startY;\n\tconst speed = Math.max(Math.abs((distanceX / 1000) * SCROLL_TIME), Math.abs((distanceY / 1000) * SCROLL_TIME));\n\n\t// Temporarily disables any scroll snapping that may be active since it fights for control over the scroller with this polyfill\n\tlet scrollSnapFix: DisableScrollSnapResult | undefined = disableScrollSnap(scroller);\n\n\trequestAnimationFrame(function animate(timestamp: number) {\n\t\tif (start == null) {\n\t\t\tstart = timestamp;\n\t\t}\n\t\ttimeLapsed += timestamp - startTime;\n\t\tconst percentage = Math.max(0, Math.min(1, speed === 0 ? 0 : timeLapsed / speed));\n\t\tconst positionX = Math.floor(startX + distanceX * ease(percentage));\n\t\tconst positionY = Math.floor(startY + distanceY * ease(percentage));\n\n\t\tmethod(positionX, positionY);\n\n\t\tif (positionX !== endX || positionY !== endY) {\n\t\t\trequestAnimationFrame(animate);\n\t\t\tstart = timestamp;\n\t\t} else {\n\t\t\tif (scrollSnapFix != null) {\n\t\t\t\tscrollSnapFix.reset();\n\t\t\t\tscrollSnapFix = undefined;\n\t\t\t}\n\t\t}\n\t});\n}\n","/**\n * Returns a High Resolution timestamp if possible, otherwise fallbacks to Date.now()\n * @returns {number}\n */\nexport function now(): number {\n\tif (\"performance\" in window) return performance.now();\n\treturn Date.now();\n}\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scroll;\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const WINDOW_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : window.scroll;\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollBy;\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const WINDOW_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollBy;\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollTo;\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const WINDOW_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollTo;\n","import {ScrollMethodName} from \"./scroll-method-name\";\nimport {ELEMENT_ORIGINAL_SCROLL} from \"../original/element/scroll\";\nimport {WINDOW_ORIGINAL_SCROLL} from \"../original/window/scroll\";\nimport {ELEMENT_ORIGINAL_SCROLL_BY} from \"../original/element/scroll-by\";\nimport {WINDOW_ORIGINAL_SCROLL_BY} from \"../original/window/scroll-by\";\nimport {ELEMENT_ORIGINAL_SCROLL_TO} from \"../original/element/scroll-to\";\nimport {WINDOW_ORIGINAL_SCROLL_TO} from \"../original/window/scroll-to\";\nimport {IAdjustableElement} from \"../adjustable-element/i-adjustable-element\";\n\n/**\n * A fallback if Element.prototype.scroll is not defined\n * @param {number} x\n * @param {number} y\n */\nfunction elementPrototypeScrollFallback(this: IAdjustableElement, x: number, y: number): void {\n\tthis.__adjustingScrollPosition = true;\n\tthis.scrollLeft = x;\n\tthis.scrollTop = y;\n\tdelete this.__adjustingScrollPosition;\n}\n\n/**\n * A fallback if Element.prototype.scrollTo is not defined\n * @param {number} x\n * @param {number} y\n */\nfunction elementPrototypeScrollToFallback(this: IAdjustableElement, x: number, y: number): void {\n\treturn elementPrototypeScrollFallback.call(this, x, y);\n}\n\n/**\n * A fallback if Element.prototype.scrollBy is not defined\n * @param {number} x\n * @param {number} y\n */\nfunction elementPrototypeScrollByFallback(this: IAdjustableElement, x: number, y: number): void {\n\tthis.__adjustingScrollPosition = true;\n\tthis.scrollLeft += x;\n\tthis.scrollTop += y;\n\tdelete this.__adjustingScrollPosition;\n}\n\n/**\n * Gets the original non-patched prototype method for the given kind\n * @param {ScrollMethodName} kind\n * @param {Element|Window} element\n * @return {Function}\n */\nexport function getOriginalScrollMethodForKind(kind: ScrollMethodName, element: Element | Window): Function {\n\tswitch (kind) {\n\t\tcase \"scroll\":\n\t\t\tif (element instanceof Element) {\n\t\t\t\tif (ELEMENT_ORIGINAL_SCROLL != null) {\n\t\t\t\t\treturn ELEMENT_ORIGINAL_SCROLL;\n\t\t\t\t} else {\n\t\t\t\t\treturn elementPrototypeScrollFallback;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn WINDOW_ORIGINAL_SCROLL!;\n\t\t\t}\n\n\t\tcase \"scrollBy\":\n\t\t\tif (element instanceof Element) {\n\t\t\t\tif (ELEMENT_ORIGINAL_SCROLL_BY != null) {\n\t\t\t\t\treturn ELEMENT_ORIGINAL_SCROLL_BY;\n\t\t\t\t} else {\n\t\t\t\t\treturn elementPrototypeScrollByFallback;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn WINDOW_ORIGINAL_SCROLL_BY!;\n\t\t\t}\n\n\t\tcase \"scrollTo\":\n\t\t\tif (element instanceof Element) {\n\t\t\t\tif (ELEMENT_ORIGINAL_SCROLL_TO != null) {\n\t\t\t\t\treturn ELEMENT_ORIGINAL_SCROLL_TO;\n\t\t\t\t} else {\n\t\t\t\t\treturn elementPrototypeScrollToFallback;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn WINDOW_ORIGINAL_SCROLL_TO!;\n\t\t\t}\n\t}\n}\n","import {ISmoothScrollOptions} from \"../smooth-scroll-options/i-smooth-scroll-options\";\nimport {now} from \"../../util/now\";\nimport {ScrollMethodName} from \"../../scroll-method/scroll-method-name\";\nimport {getOriginalScrollMethodForKind} from \"../../scroll-method/get-original-scroll-method-for-kind\";\nimport {getScrollingElement} from \"../../util/scrolling-element\";\nimport {ScrollSnappable} from \"../../util/scroll-snappable\";\n\n/**\n * Gets the Smooth Scroll Options to use for the step function\n * @param {Element|Window} element\n * @param {number} x\n * @param {number} y\n * @param {ScrollMethodName} kind\n * @returns {ISmoothScrollOptions}\n */\nexport function getSmoothScrollOptions(element: Element | Window, x: number, y: number, kind: ScrollMethodName): ISmoothScrollOptions {\n\tconst startTime = now();\n\n\tif (!(element instanceof Element)) {\n\t\t// Use window as the scroll container\n\t\tconst {scrollX, pageXOffset, scrollY, pageYOffset} = window;\n\t\tconst startX = scrollX == null || scrollX === 0 ? pageXOffset : scrollX;\n\t\tconst startY = scrollY == null || scrollY === 0 ? pageYOffset : scrollY;\n\t\treturn {\n\t\t\tstartTime,\n\t\t\tstartX,\n\t\t\tstartY,\n\t\t\tendX: Math.floor(kind === \"scrollBy\" ? startX + x : x),\n\t\t\tendY: Math.floor(kind === \"scrollBy\" ? startY + y : y),\n\t\t\tmethod: getOriginalScrollMethodForKind(\"scrollTo\", window).bind(window),\n\t\t\tscroller: getScrollingElement() as ScrollSnappable\n\t\t};\n\t} else {\n\t\tconst {scrollLeft, scrollTop} = element;\n\t\tconst startX = scrollLeft;\n\t\tconst startY = scrollTop;\n\t\treturn {\n\t\t\tstartTime,\n\t\t\tstartX,\n\t\t\tstartY,\n\t\t\tendX: Math.floor(kind === \"scrollBy\" ? startX + x : x),\n\t\t\tendY: Math.floor(kind === \"scrollBy\" ? startY + y : y),\n\t\t\tmethod: getOriginalScrollMethodForKind(\"scrollTo\", element).bind(element),\n\t\t\tscroller: element as ScrollSnappable\n\t\t};\n\t}\n}\n","/**\n * Ensures that the given value is numeric\n * @param {number} value\n * @return {number}\n */\nexport function ensureNumeric(value: unknown): number {\n\tif (value == null) return 0;\n\telse if (typeof value === \"number\") {\n\t\treturn value;\n\t} else if (typeof value === \"string\") {\n\t\treturn parseFloat(value);\n\t} else {\n\t\treturn 0;\n\t}\n}\n","/**\n * Returns true if the given value is some ScrollToOptions\n * @param {number | ScrollToOptions} value\n * @return {value is ScrollToOptions}\n */\nexport function isScrollToOptions(value: number | ScrollToOptions | undefined): value is ScrollToOptions {\n\treturn value != null && typeof value === \"object\";\n}\n","import {getScrollBehavior} from \"../util/get-scroll-behavior\";\nimport {smoothScroll} from \"../smooth-scroll/smooth-scroll/smooth-scroll\";\nimport {getSmoothScrollOptions} from \"../smooth-scroll/get-smooth-scroll-options/get-smooth-scroll-options\";\nimport {ensureNumeric} from \"../util/ensure-numeric\";\nimport {isScrollToOptions} from \"../util/is-scroll-to-options\";\nimport {ScrollMethodName} from \"../scroll-method/scroll-method-name\";\nimport {getOriginalScrollMethodForKind} from \"../scroll-method/get-original-scroll-method-for-kind\";\n\n/**\n * Handles a scroll method\n * @param {Element|Window} element\n * @param {ScrollMethodName} kind\n * @param {number | ScrollToOptions} optionsOrX\n * @param {number} y\n */\nexport function handleScrollMethod(element: Element | Window, kind: ScrollMethodName, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\tonScrollWithOptions(getScrollToOptionsWithValidation(optionsOrX, y), element, kind);\n}\n\n/**\n * Invoked when a 'ScrollToOptions' dict is provided to 'scroll()' as the first argument\n * @param {ScrollToOptions} options\n * @param {Element|Window} element\n * @param {ScrollMethodName} kind\n */\nfunction onScrollWithOptions(options: Required<ScrollToOptions>, element: Element | Window, kind: ScrollMethodName): void {\n\tconst behavior = getScrollBehavior(element, options);\n\n\t// If the behavior is 'auto' apply instantaneous scrolling\n\tif (behavior == null || behavior === \"auto\") {\n\t\tgetOriginalScrollMethodForKind(kind, element).call(element, options.left, options.top);\n\t} else {\n\t\tsmoothScroll(getSmoothScrollOptions(element, options.left, options.top, kind));\n\t}\n}\n\n/**\n * Normalizes the given scroll coordinates\n * @param {number?} x\n * @param {number?} y\n * @return {Required<Pick<ScrollToOptions, \"top\" | \"left\">>}\n */\nfunction normalizeScrollCoordinates(x: number | undefined, y: number | undefined): Required<Pick<ScrollToOptions, \"top\" | \"left\">> {\n\treturn {\n\t\tleft: ensureNumeric(x),\n\t\ttop: ensureNumeric(y)\n\t};\n}\n\n/**\n * Gets ScrollToOptions based on the given arguments. Will throw if validation fails\n * @param {number | ScrollToOptions} optionsOrX\n * @param {number} y\n * @return {Required<ScrollToOptions>}\n */\nfunction getScrollToOptionsWithValidation(optionsOrX?: number | ScrollToOptions, y?: number): Required<ScrollToOptions> {\n\t// If only one argument is given, and it isn't an options object, throw a TypeError\n\tif (y === undefined && !isScrollToOptions(optionsOrX)) {\n\t\tthrow new TypeError(\"Failed to execute 'scroll' on 'Element': parameter 1 ('options') is not an object.\");\n\t}\n\n\t// Scroll based on the primitive values given as arguments\n\tif (!isScrollToOptions(optionsOrX)) {\n\t\treturn {\n\t\t\t...normalizeScrollCoordinates(optionsOrX, y),\n\t\t\tbehavior: \"auto\"\n\t\t};\n\t}\n\n\t// Scroll based on the received options object\n\telse {\n\t\treturn {\n\t\t\t...normalizeScrollCoordinates(optionsOrX.left, optionsOrX.top),\n\t\t\tbehavior: optionsOrX.behavior == null ? \"auto\" : optionsOrX.behavior\n\t\t};\n\t}\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scroll' method on the Element prototype\n */\nexport function patchElementScroll(): void {\n\tElement.prototype.scroll = function(this: Element, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scroll\", optionsOrX, y);\n\t};\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scrollBy' method on the Element prototype\n */\nexport function patchElementScrollBy(): void {\n\tElement.prototype.scrollBy = function(this: Element, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scrollBy\", optionsOrX, y);\n\t};\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scrollTo' method on the Element prototype\n */\nexport function patchElementScrollTo(): void {\n\tElement.prototype.scrollTo = function(this: Element, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scrollTo\", optionsOrX, y);\n\t};\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scroll' method on the Window prototype\n */\nexport function patchWindowScroll(): void {\n\twindow.scroll = function(this: Window, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scroll\", optionsOrX, y);\n\t};\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scrollBy' method on the Window prototype\n */\nexport function patchWindowScrollBy(): void {\n\twindow.scrollBy = function(this: Window, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scrollBy\", optionsOrX, y);\n\t};\n}\n","import {handleScrollMethod} from \"../shared\";\n\n/**\n * Patches the 'scrollTo' method on the Window prototype\n */\nexport function patchWindowScrollTo(): void {\n\twindow.scrollTo = function(this: Window, optionsOrX?: number | ScrollToOptions, y?: number): void {\n\t\thandleScrollMethod(this, \"scrollTo\", optionsOrX, y);\n\t};\n}\n","// tslint:disable:no-any\n\n/**\n * Gets the parent of an element, taking into account DocumentFragments, ShadowRoots, as well as the root context (window)\n * @param {EventTarget} currentElement\n * @returns {EventTarget | null}\n */\nexport function getParent(currentElement: EventTarget): Element | Window | Node | null {\n\tif (\"nodeType\" in currentElement && (<Node>currentElement).nodeType === 1) {\n\t\treturn (<Node>currentElement).parentNode;\n\t}\n\n\tif (\"ShadowRoot\" in window && currentElement instanceof (<any>window).ShadowRoot) {\n\t\treturn (<ShadowRoot>currentElement).host;\n\t} else if (currentElement === document) {\n\t\treturn window;\n\t} else if (currentElement instanceof Node) return currentElement.parentNode;\n\n\treturn null;\n}\n","import {getParent} from \"./get-parent\";\nimport {getScrollBehavior} from \"./get-scroll-behavior\";\nimport {getScrollingElement} from \"./scrolling-element\";\n\n/**\n * Returns true if the given overflow property represents a scrollable overflow value\n * @param {string | null} overflow\n * @return {boolean}\n */\nfunction canOverflow(overflow: string | null): boolean {\n\treturn overflow !== \"visible\" && overflow !== \"clip\";\n}\n\n/**\n * Returns true if the given element is scrollable\n * @param {Element} element\n * @return {boolean}\n */\nfunction isScrollable(element: Element) {\n\tif (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n\t\tconst style = getComputedStyle(element, null);\n\t\treturn canOverflow(style.overflowY) || canOverflow(style.overflowX);\n\t}\n\n\treturn false;\n}\n\n/**\n * Finds the nearest ancestor of an element that can scroll\n * @param {Element} target\n * @returns {Element|Window?}\n */\nexport function findNearestAncestorsWithScrollBehavior(target: Element | HTMLElement): [Element | HTMLElement, ScrollBehavior] {\n\tlet currentElement: Element | HTMLElement = target;\n\tconst scrollingElement = getScrollingElement();\n\n\twhile (currentElement != null) {\n\t\tconst behavior = getScrollBehavior(currentElement);\n\t\tif (behavior != null && (currentElement === scrollingElement || isScrollable(currentElement))) {\n\t\t\treturn [currentElement, behavior];\n\t\t}\n\n\t\tconst parent = getParent(currentElement);\n\t\tcurrentElement = parent as Element;\n\t}\n\n\t// No such element could be found. Start over, but this time find the nearest ancestor that can simply scroll\n\tcurrentElement = target;\n\n\twhile (currentElement != null) {\n\t\tif (currentElement === scrollingElement || isScrollable(currentElement)) {\n\t\t\treturn [currentElement, \"auto\"];\n\t\t}\n\n\t\tconst parent = getParent(currentElement);\n\t\tcurrentElement = parent as Element;\n\t}\n\n\t// Default to the scrolling element\n\treturn [scrollingElement, \"auto\"];\n}\n","import {getParent} from \"./get-parent\";\n\n// tslint:disable:no-any\n\n/**\n * Finds the nearest root from an element\n * @param {Element} target\n * @returns {Document|ShadowRoot}\n */\nexport function findNearestRoot(target: Element): Document | ShadowRoot {\n\tlet currentElement: EventTarget | null = target;\n\twhile (currentElement != null) {\n\t\tif (\"ShadowRoot\" in window && currentElement instanceof (window as any).ShadowRoot) {\n\t\t\t// Assume this is a ShadowRoot\n\t\t\treturn currentElement as ShadowRoot;\n\t\t}\n\n\t\tconst parent = getParent(currentElement);\n\n\t\tif (parent === currentElement) {\n\t\t\treturn document;\n\t\t}\n\n\t\tcurrentElement = parent;\n\t}\n\treturn document;\n}\n","/**\n * Gets the origin of the given Location or HTMLAnchorElement if available in the runtime, and otherwise shims it. (it's a one-liner)\n * @returns {string}\n */\nexport function getLocationOrigin(locationLike: Location | HTMLAnchorElement = location): string {\n\tif (\"origin\" in locationLike && locationLike.origin != null) {\n\t\treturn locationLike.origin;\n\t}\n\n\tlet port = locationLike.port != null && locationLike.port.length > 0 ? `:${locationLike.port}` : \"\";\n\n\tif (locationLike.protocol === \"http:\" && port === \":80\") {\n\t\tport = \"\";\n\t} else if (locationLike.protocol === \"https:\" && port === \":443\") {\n\t\tport = \"\";\n\t}\n\n\treturn `${locationLike.protocol}//${locationLike.hostname}${port}`;\n}\n","import {findNearestAncestorsWithScrollBehavior} from \"../../util/find-nearest-ancestor-with-scroll-behavior\";\nimport {findNearestRoot} from \"../../util/find-nearest-root\";\nimport {getLocationOrigin} from \"../../util/get-location-origin\";\n\n/**\n * A Regular expression that matches id's of the form \"#[digit]\"\n * @type {RegExp}\n */\nconst ID_WITH_LEADING_DIGIT_REGEXP = /^#\\d/;\n\n/**\n * Catches anchor navigation to IDs within the same root and ensures that they can be smooth-scrolled\n * if the scroll behavior is smooth in the first rooter within that context\n */\nexport function catchNavigation(): void {\n\t// Listen for 'click' events globally\n\twindow.addEventListener(\"click\", e => {\n\t\t// Only work with trusted events on HTMLAnchorElements\n\t\tif (!e.isTrusted || !(e.target instanceof HTMLAnchorElement)) return;\n\n\t\tconst {pathname, search, hash} = e.target;\n\t\tconst pointsToCurrentPage =\n\t\t\tgetLocationOrigin(e.target) === getLocationOrigin(location) && pathname === location.pathname && search === location.search;\n\n\t\t// Only work with HTMLAnchorElements that navigates to a specific ID on the current page\n\t\tif (!pointsToCurrentPage || hash == null || hash.length < 1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Find the nearest root, whether it be a ShadowRoot or the document itself\n\t\tconst root = findNearestRoot(e.target);\n\n\t\t// Attempt to match the selector from that root. querySelector' doesn't support IDs that start with a digit, so work around that limitation\n\t\tconst elementMatch = hash.match(ID_WITH_LEADING_DIGIT_REGEXP) != null ? root.getElementById(hash.slice(1)) : root.querySelector(hash);\n\n\t\t// If no selector could be found, don't proceed\n\t\tif (elementMatch == null) return;\n\n\t\t// Find the nearest ancestor that can be scrolled\n\t\tconst [, behavior] = findNearestAncestorsWithScrollBehavior(elementMatch);\n\n\t\t// If the behavior isn't smooth, don't proceed\n\t\tif (behavior !== \"smooth\") return;\n\n\t\t// Otherwise, first prevent the default action.\n\t\te.preventDefault();\n\n\t\t// Now, scroll to the element with that ID\n\t\telementMatch.scrollIntoView({\n\t\t\tbehavior\n\t\t});\n\t});\n}\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL_INTO_VIEW = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollIntoView;\n","/**\n * The majority of this file is based on https://github.com/stipsan/compute-scroll-into-view (MIT license),\n * but has been rewritten to accept a scroller as an argument.\n */\nimport {getScrollingElement} from \"../../util/scrolling-element\";\n\n// tslint:disable\n\ninterface IVisualViewport {\n\theight: number;\n\twidth: number;\n}\n\ndeclare var visualViewport: IVisualViewport;\n\ninterface VisualViewportable {\n\tvisualViewport?: {\n\t\theight: number;\n\t\twidth: number;\n\t};\n}\n\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarly to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n *      \n *  target    frame\n *      \n */\nfunction alignNearest(\n\tscrollingEdgeStart: number,\n\tscrollingEdgeEnd: number,\n\tscrollingSize: number,\n\tscrollingBorderStart: number,\n\tscrollingBorderEnd: number,\n\telementEdgeStart: number,\n\telementEdgeEnd: number,\n\telementSize: number\n) {\n\t/**\n\t * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n\t *\n\t *          \n\t *        \n\t *            \n\t *                    do nothing\n\t *            \n\t *        \n\t *          \n\t *\n\t *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n\t *\n\t *         \n\t *   \n\t *                    do nothing\n\t *   \n\t *         \n\t */\n\tif (\n\t\t(elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n\t\t(elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n\t) {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n\t *\n\t *          \n\t *                 \n\t *                         \n\t *  from             to    \n\t *\n\t *                     \n\t *\n\t * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n\t *\n\t *                   \n\t *                             \n\t *  from         to      \n\t *                           \n\t *                 \n\t *                         \n\t *            \n\t *          \n\t *\n\t * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n\t *\n\t *       from                 to\n\t *                       \n\t *                   \n\t *                            \n\t *                   \n\t *                       \n\t *\n\t * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n\t *\n\t *       from                 to\n\t *                       \n\t *           \n\t *                              \n\t *           \n\t *                       \n\t */\n\tif (\n\t\t(elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n\t\t(elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n\t) {\n\t\treturn elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;\n\t}\n\n\t/**\n\t * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n\t *\n\t *                     \n\t *\n\t *  from             to    \n\t *                         \n\t *                 \n\t *          \n\t *\n\t * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n\t *\n\t *          \n\t *            \n\t *                         \n\t *                 \n\t *                           \n\t *  from         to      \n\t *                             \n\t *                   \n\t *\n\t * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n\t *\n\t *           from                 to\n\t *                           \n\t *             \n\t *                                \n\t *             \n\t *                           \n\t *\n\t * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n\t *\n\t *           from                 to\n\t *                           \n\t *                             \n\t *                                \n\t *                             \n\t *                           \n\t *\n\t */\n\tif ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) || (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {\n\t\treturn elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;\n\t}\n\n\treturn 0;\n}\n\nexport function computeScrollIntoView(target: Element, scroller: Element, options: ScrollIntoViewOptions): Pick<ScrollToOptions, \"top\" | \"left\"> {\n\tconst {block, inline} = options;\n\n\t// Used to handle the top most element that can be scrolled\n\tconst scrollingElement = getScrollingElement();\n\n\t// Support pinch-zooming properly, making sure elements scroll into the visual viewport\n\t// Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height\n\t// and viewport dimensions on window.innerWidth/Height\n\t// https://www.quirksmode.org/mobile/viewports2.html\n\t// https://bokand.github.io/viewport/index.html\n\tconst viewportWidth = (window as VisualViewportable).visualViewport != null ? visualViewport.width : innerWidth;\n\tconst viewportHeight = (window as VisualViewportable).visualViewport != null ? visualViewport.height : innerHeight;\n\n\tconst viewportX = window.scrollX != null ? window.scrollX : window.pageXOffset;\n\tconst viewportY = window.scrollY != null ? window.scrollY : window.pageYOffset;\n\n\tconst {\n\t\theight: targetHeight,\n\t\twidth: targetWidth,\n\t\ttop: targetTop,\n\t\tright: targetRight,\n\t\tbottom: targetBottom,\n\t\tleft: targetLeft\n\t} = target.getBoundingClientRect();\n\n\t// These values mutate as we loop through and generate scroll coordinates\n\tconst targetBlock: number = block === \"start\" || block === \"nearest\" ? targetTop : block === \"end\" ? targetBottom : targetTop + targetHeight / 2; // block === 'center\n\tconst targetInline: number = inline === \"center\" ? targetLeft + targetWidth / 2 : inline === \"end\" ? targetRight : targetLeft; // inline === 'start || inline === 'nearest\n\n\tconst {height, width, top, right, bottom, left} = scroller.getBoundingClientRect();\n\n\tconst frameStyle = getComputedStyle(scroller);\n\tconst borderLeft = parseInt(frameStyle.borderLeftWidth as string, 10);\n\tconst borderTop = parseInt(frameStyle.borderTopWidth as string, 10);\n\tconst borderRight = parseInt(frameStyle.borderRightWidth as string, 10);\n\tconst borderBottom = parseInt(frameStyle.borderBottomWidth as string, 10);\n\n\tlet blockScroll: number = 0;\n\tlet inlineScroll: number = 0;\n\n\t// The property existance checks for offset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here\n\t// @TODO find out if the \"as HTMLElement\" overrides can be dropped\n\tconst scrollbarWidth =\n\t\t\"offsetWidth\" in scroller ? (scroller as HTMLElement).offsetWidth - (scroller as HTMLElement).clientWidth - borderLeft - borderRight : 0;\n\tconst scrollbarHeight =\n\t\t\"offsetHeight\" in scroller ? (scroller as HTMLElement).offsetHeight - (scroller as HTMLElement).clientHeight - borderTop - borderBottom : 0;\n\n\tif (scrollingElement === scroller) {\n\t\t// Handle viewport logic (document.documentElement or document.body)\n\n\t\tif (block === \"start\") {\n\t\t\tblockScroll = targetBlock;\n\t\t} else if (block === \"end\") {\n\t\t\tblockScroll = targetBlock - viewportHeight;\n\t\t} else if (block === \"nearest\") {\n\t\t\tblockScroll = alignNearest(\n\t\t\t\tviewportY,\n\t\t\t\tviewportY + viewportHeight,\n\t\t\t\tviewportHeight,\n\t\t\t\tborderTop,\n\t\t\t\tborderBottom,\n\t\t\t\tviewportY + targetBlock,\n\t\t\t\tviewportY + targetBlock + targetHeight,\n\t\t\t\ttargetHeight\n\t\t\t);\n\t\t} else {\n\t\t\t// block === 'center' is the default\n\t\t\tblockScroll = targetBlock - viewportHeight / 2;\n\t\t}\n\n\t\tif (inline === \"start\") {\n\t\t\tinlineScroll = targetInline;\n\t\t} else if (inline === \"center\") {\n\t\t\tinlineScroll = targetInline - viewportWidth / 2;\n\t\t} else if (inline === \"end\") {\n\t\t\tinlineScroll = targetInline - viewportWidth;\n\t\t} else {\n\t\t\t// inline === 'nearest' is the default\n\t\t\tinlineScroll = alignNearest(\n\t\t\t\tviewportX,\n\t\t\t\tviewportX + viewportWidth,\n\t\t\t\tviewportWidth,\n\t\t\t\tborderLeft,\n\t\t\t\tborderRight,\n\t\t\t\tviewportX + targetInline,\n\t\t\t\tviewportX + targetInline + targetWidth,\n\t\t\t\ttargetWidth\n\t\t\t);\n\t\t}\n\n\t\t// Apply scroll position offsets and ensure they are within bounds\n\t\t// @TODO add more test cases to cover this 100%\n\t\tblockScroll = Math.max(0, blockScroll + viewportY);\n\t\tinlineScroll = Math.max(0, inlineScroll + viewportX);\n\t} else {\n\t\t// Handle each scrolling frame that might exist between the target and the viewport\n\n\t\tif (block === \"start\") {\n\t\t\tblockScroll = targetBlock - top - borderTop;\n\t\t} else if (block === \"end\") {\n\t\t\tblockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;\n\t\t} else if (block === \"nearest\") {\n\t\t\tblockScroll = alignNearest(\n\t\t\t\ttop,\n\t\t\t\tbottom,\n\t\t\t\theight,\n\t\t\t\tborderTop,\n\t\t\t\tborderBottom + scrollbarHeight,\n\t\t\t\ttargetBlock,\n\t\t\t\ttargetBlock + targetHeight,\n\t\t\t\ttargetHeight\n\t\t\t);\n\t\t} else {\n\t\t\t// block === 'center' is the default\n\t\t\tblockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;\n\t\t}\n\n\t\tif (inline === \"start\") {\n\t\t\tinlineScroll = targetInline - left - borderLeft;\n\t\t} else if (inline === \"center\") {\n\t\t\tinlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;\n\t\t} else if (inline === \"end\") {\n\t\t\tinlineScroll = targetInline - right + borderRight + scrollbarWidth;\n\t\t} else {\n\t\t\t// inline === 'nearest' is the default\n\t\t\tinlineScroll = alignNearest(\n\t\t\t\tleft,\n\t\t\t\tright,\n\t\t\t\twidth,\n\t\t\t\tborderLeft,\n\t\t\t\tborderRight + scrollbarWidth,\n\t\t\t\ttargetInline,\n\t\t\t\ttargetInline + targetWidth,\n\t\t\t\ttargetWidth\n\t\t\t);\n\t\t}\n\n\t\tconst {scrollLeft, scrollTop} = scroller;\n\t\t// Ensure scroll coordinates are not out of bounds while applying scroll offsets\n\t\tblockScroll = Math.max(0, Math.min(scrollTop + blockScroll, scroller.scrollHeight - height + scrollbarHeight));\n\t\tinlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, scroller.scrollWidth - width + scrollbarWidth));\n\t}\n\n\treturn {\n\t\ttop: blockScroll,\n\t\tleft: inlineScroll\n\t};\n}\n","import {findNearestAncestorsWithScrollBehavior} from \"../../util/find-nearest-ancestor-with-scroll-behavior\";\nimport {ELEMENT_ORIGINAL_SCROLL_INTO_VIEW} from \"../../original/element/scroll-into-view\";\nimport {computeScrollIntoView} from \"./compute-scroll-into-view\";\nimport {getOriginalScrollMethodForKind} from \"../../scroll-method/get-original-scroll-method-for-kind\";\n\n/**\n * Patches the 'scrollIntoView' method on the Element prototype\n */\nexport function patchElementScrollIntoView(): void {\n\tElement.prototype.scrollIntoView = function(this: Element, arg?: boolean | ScrollIntoViewOptions): void {\n\t\tconst normalizedOptions: ScrollIntoViewOptions =\n\t\t\targ == null || arg === true\n\t\t\t\t? {\n\t\t\t\t\t\tblock: \"start\",\n\t\t\t\t\t\tinline: \"nearest\"\n\t\t\t\t  }\n\t\t\t\t: arg === false\n\t\t\t\t? {\n\t\t\t\t\t\tblock: \"end\",\n\t\t\t\t\t\tinline: \"nearest\"\n\t\t\t\t  }\n\t\t\t\t: arg;\n\n\t\t// Find the nearest ancestor that can be scrolled\n\t\tconst [ancestorWithScroll, ancestorWithScrollBehavior] = findNearestAncestorsWithScrollBehavior(this);\n\n\t\tconst behavior = normalizedOptions.behavior != null ? normalizedOptions.behavior : ancestorWithScrollBehavior;\n\n\t\t// If the behavior isn't smooth, simply invoke the original implementation and do no more\n\t\tif (behavior !== \"smooth\") {\n\t\t\t// Assert that 'scrollIntoView' is actually defined\n\t\t\tif (ELEMENT_ORIGINAL_SCROLL_INTO_VIEW != null) {\n\t\t\t\tELEMENT_ORIGINAL_SCROLL_INTO_VIEW.call(this, normalizedOptions);\n\t\t\t}\n\n\t\t\t// Otherwise, invoke 'scrollTo' instead and provide the scroll coordinates\n\t\t\telse {\n\t\t\t\tconst {top, left} = computeScrollIntoView(this, ancestorWithScroll, normalizedOptions);\n\t\t\t\tgetOriginalScrollMethodForKind(\"scrollTo\", this).call(this, left, top);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tancestorWithScroll.scrollTo({\n\t\t\tbehavior,\n\t\t\t...computeScrollIntoView(this, ancestorWithScroll, normalizedOptions)\n\t\t});\n\t};\n\n\t// On IE11, HTMLElement has its own declaration of scrollIntoView and does not inherit this from the prototype chain, so we'll need to patch that one too.\n\tif (HTMLElement.prototype.scrollIntoView != null && HTMLElement.prototype.scrollIntoView !== Element.prototype.scrollIntoView) {\n\t\tHTMLElement.prototype.scrollIntoView = Element.prototype.scrollIntoView;\n\t}\n}\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT\n\t? undefined\n\t: Object.getOwnPropertyDescriptor(Element.prototype, \"scrollTop\")!.set!;\n","import {handleScrollMethod} from \"../shared\";\nimport {ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR} from \"../../original/element/scroll-top\";\n\n/**\n * Patches the 'scrollTop' property descriptor on the Element prototype\n */\nexport function patchElementScrollTop(): void {\n\tObject.defineProperty(Element.prototype, \"scrollTop\", {\n\t\tset(scrollTop: number) {\n\t\t\tif (this.__adjustingScrollPosition) {\n\t\t\t\treturn ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR!.call(this, scrollTop);\n\t\t\t}\n\n\t\t\thandleScrollMethod(this, \"scrollTo\", this.scrollLeft, scrollTop);\n\t\t\treturn scrollTop;\n\t\t}\n\t});\n}\n","import {UNSUPPORTED_ENVIRONMENT} from \"../../support/unsupported-environment\";\n\nexport const ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT\n\t? undefined\n\t: Object.getOwnPropertyDescriptor(Element.prototype, \"scrollLeft\")!.set!;\n","import {handleScrollMethod} from \"../shared\";\nimport {ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR} from \"../../original/element/scroll-left\";\n\n/**\n * Patches the 'scrollLeft' property descriptor on the Element prototype\n */\nexport function patchElementScrollLeft(): void {\n\tObject.defineProperty(Element.prototype, \"scrollLeft\", {\n\t\tset(scrollLeft: number) {\n\t\t\tif (this.__adjustingScrollPosition) {\n\t\t\t\treturn ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR!.call(this, scrollLeft);\n\t\t\t}\n\n\t\t\thandleScrollMethod(this, \"scrollTo\", scrollLeft, this.scrollTop);\n\t\t\treturn scrollLeft;\n\t\t}\n\t});\n}\n","import {patchElementScroll} from \"./element/scroll\";\nimport {patchElementScrollBy} from \"./element/scroll-by\";\nimport {patchElementScrollTo} from \"./element/scroll-to\";\nimport {patchWindowScroll} from \"./window/scroll\";\nimport {patchWindowScrollBy} from \"./window/scroll-by\";\nimport {patchWindowScrollTo} from \"./window/scroll-to\";\nimport {catchNavigation} from \"./anchor/catch-navigation\";\nimport {patchElementScrollIntoView} from \"./element/scroll-into-view\";\nimport {patchElementScrollTop} from \"./element/scroll-top\";\nimport {patchElementScrollLeft} from \"./element/scroll-left\";\n\n/**\n * Applies the polyfill\n */\nexport function patch(): void {\n\t// Element.prototype methods\n\tpatchElementScroll();\n\tpatchElementScrollBy();\n\tpatchElementScrollTo();\n\tpatchElementScrollIntoView();\n\n\t// Element.prototype descriptors\n\tpatchElementScrollLeft();\n\tpatchElementScrollTop();\n\n\t// window methods\n\tpatchWindowScroll();\n\tpatchWindowScrollBy();\n\tpatchWindowScrollTo();\n\n\t// Navigation\n\tcatchNavigation();\n}\n","import {UNSUPPORTED_ENVIRONMENT} from \"./unsupported-environment\";\n\n/**\n * Is true if the browser natively supports the Element.prototype.[scroll|scrollTo|scrollBy|scrollIntoView] methods\n * @type {boolean}\n */\nexport const SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS = UNSUPPORTED_ENVIRONMENT\n\t? false\n\t: \"scroll\" in Element.prototype && \"scrollTo\" in Element.prototype && \"scrollBy\" in Element.prototype && \"scrollIntoView\" in Element.prototype;\n","import {SUPPORTS_SCROLL_BEHAVIOR} from \"./support/supports-scroll-behavior\";\nimport {patch} from \"./patch/patch\";\nimport {SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS} from \"./support/supports-element-prototype-scroll-methods\";\nimport {UNSUPPORTED_ENVIRONMENT} from \"./support/unsupported-environment\";\n\nif (!UNSUPPORTED_ENVIRONMENT && (!SUPPORTS_SCROLL_BEHAVIOR || !SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS)) {\n\tpatch();\n}\n"]}}